
#define  _CRT_SECURE_NO_WARNINGS
#define inf 500
#include <stdio.h>
#include <stack>
#include <string.h>
#include <time.h>
#include <vector>
#include<algorithm>
#include <iostream>
#include <string>
#include <ctime>
#include <cstdlib>
#include <math.h>
using namespace std;

//卡秒退
int threshold = 0.95 * (double)CLOCKS_PER_SEC; //CLOCKS_PER_SEC 和 clock()的含义可百度
int start_time, current_time;

//声明全局变量,函数
const int SIZE = 11;
int iniboard[SIZE][SIZE] = { 0 };//本方1，对方-1，空白0
int board[SIZE][SIZE] = { 0 };
int Current_board[11][11] = { 0 };			//当前棋局                                     
int color;
unsigned int round0;
int visited[11][11] = { 0 };
int who_first();			//谁先手,先下返回1,后下返回0


struct Union_node
{
	struct Union_node* father;
	int x;
	int y;
};
struct Union_node Current_union[11][11];			//并查集
struct Union_node union_board[11][11];
struct Union_node boundary[4] = { {&boundary[0],-1,0},{&boundary[1],-1,1},{&boundary[2],-1,2},{&boundary[3],-1,3}};						//并查集的四个边界   红方1，蓝方1，红方2，蓝方2
struct Union_node Current_boundary[4] = { {&Current_boundary[0],-1,0},{&Current_boundary[1],-1,1},{&Current_boundary[2],-1,2},{&Current_boundary[3],-1,3}};
stack<int> useless_nodes_x, useless_node_y;
class MCTNode
{
private:
	int x, y;
	vector<MCTNode*> child;			//子节点集合
	MCTNode* parent;			//父节点，加减分用
	int score;				//分数
	int search_time;			//搜索次数
	int win_time;			//胜利次数
	//	int children_search_time;			//所有子节点搜索次数
public:
	MCTNode(MCTNode* parent, int x, int y);
	//选择子节点，返回值为MCTNode*类型
	MCTNode* select(MCTNode* node);
	//拓展该节点，返回值为空
	MCTNode* expand(MCTNode* node);
	//模拟，返回值为int类型，判断输赢
	int simulate();
	//反向传播算分函数
	void backup(MCTNode* node, int reward);
	//UCT函数
	double UCT();
	//判断结束
	int isTerminal();
	//判断探索完成
	//	int isAllExpand();
	//选择最好子节点
	MCTNode* bestChild(MCTNode* node);
	//全过程
	MCTNode* monteCarloTreeSearch(int x, int y);
	void Result_Output();
	
};
struct randomnode {
	int x;
	int y;
	int whatcolor;
};

int xgznode_num = 4;



//判断输赢函数
int is_win();
//并查集初始化
void union_find();
//落点时并查集的更新
void union_find_update(int x, int y, int color);
//找父节点函数
Union_node* union_find_father(Union_node* son);
//初始化的找父节点函数
Union_node* union_find_father_first(Union_node* son);
//并查集重置，退回根结点时使用
void union_board_reset();
//结构查找重置，返回根节点时使用
void visited_reset();
//填充特殊结构的函数
void fill_board();

class dis
{
public:
	int first;
	int second;
	//int distance;
};


class xgznode
{
public:
	int fill;
	int i;
	int j;
	int blue_val;
	int red_val;
	int bluedistance;
	int reddistance;
	dis blue_down;
	dis blue_up;
	dis red_left;
	dis red_right;

	void tofill(int fillcolor) // fillcolor == 1  ->   red
	{
		if (fillcolor == 1)
		{
			this->fill = 1;
			this->bluedistance = inf;
			this->reddistance = 128;
			this->blue_down.first = inf;
			this->blue_down.second = inf;
			this->blue_up.first = inf;
			this->blue_up.second = inf;
			this->red_left.first = 128;
			this->red_left.second = 128;
			this->red_right.first = 128;
			this->red_right.second = 128;
			this->blue_val = inf;
			this->red_val = 0;
		}
		else if (fillcolor == -1)
		{
			this->fill = 1;
			this->bluedistance = 128;
			this->reddistance = inf;
			this->blue_down.first = 128;
			this->blue_down.second = 128;
			this->blue_up.first = 128;
			this->blue_up.second = 128;
			this->red_left.first = inf;
			this->red_left.second = inf;
			this->red_right.first = inf;
			this->red_right.second = inf;
			this->blue_val = 0;
			this->red_val = inf;
		}
		else
		{
			this->fill = 0;
			this->bluedistance = 128;
			this->reddistance = 128;
			this->blue_down.first = 128;
			this->blue_down.second = 128;
			this->blue_up.first = 128;
			this->blue_up.second = 128;
			this->red_left.first = 128;
			this->red_left.second = 128;
			this->red_right.first = 128;
			this->red_right.second = 128;
			this->blue_val = 1;
			this->red_val = 1;
		}
		return;
	}
	xgznode()
	{
		this->fill = 0;
		this->i = -1;
		this->j = -1;
		this->red_val = 1;
		this->blue_val = 1;
		this->bluedistance = inf;
		this->reddistance = inf;
		this->blue_down.first = inf;
		this->blue_down.second = inf;
		this->blue_up.first = inf;
		this->blue_up.second = inf;
		this->red_left.first = inf;
		this->red_left.second = inf;
		this->red_right.first = inf;
		this->red_right.second = inf;
	}
};

xgznode myboard[SIZE][SIZE];

//定义全局变量,函数
void make_myboard();
xgznode** to_get_twodis_best_point();  // my = 1 -> mycolor
int blue_twodis_to_down(int aim);
int blue_twodis_to_up(int aim);
int blue_to_down_to_right(int aim);
int blue_twodis_to_down_to_down(int aim);
int blue_twodis_to_up_to_up(int aim);
int blue_to_up_to_left(int aim);

int red_twodis_to_left(int aim);
int red_twodis_to_right(int aim);
int red_to_left_to_up(int aim);
int red_twodis_to_left_to_left(int aim);
int red_to_right_to_down(int aim);
int red_twodis_to_right_to_right(int aim);

void updata();
int get_pot(int color);



void make_myboard()              //make red = 1;
{
	int red = Current_board[1][2];
	for (int i = 0; i < 11; i++)
	{
		for (int j = 0; j < 11; j++)
		{
			if (Current_board[i][j] == red)
			{
				myboard[i][j].i = i;
				myboard[i][j].j = j;
				myboard[i][j].tofill(1);
			}
			else if (Current_board[i][j] == 0 - red)
			{
				myboard[i][j].i = i;
				myboard[i][j].j = j;
				myboard[i][j].tofill(-1);
			}
			else
			{
				myboard[i][j].i = i;
				myboard[i][j].j = j;
				myboard[i][j].tofill(0);
			}
		}
	}
	return;
}

int blue_twodis_to_down(int aim)
{
	if (aim == 0)
	{
		for (int i = 0; i < SIZE; i++)
		{
			if (myboard[i][aim].blue_val < inf && myboard[i][aim].blue_val > 0)
			{
				myboard[i][aim].blue_down.first = 0;
				myboard[i][aim].blue_down.second = 1;
			}
			else if (myboard[i][aim].blue_val == 0)
			{
				myboard[i][aim].blue_down.first = 0;
				myboard[i][aim].blue_down.second = 0;
			}
		}
	}
	else
	{
		for (int i = 0; i < SIZE - 1; i++)
		{
			int min = 0;
			int max = 0;
			if (myboard[i][aim - 1].blue_down.second + myboard[i][aim].blue_val > myboard[i + 1][aim - 1].blue_down.second + myboard[i][aim].blue_val)
			{
				max = myboard[i][aim - 1].blue_down.second + myboard[i][aim].blue_val;
				min = myboard[i + 1][aim - 1].blue_down.second + myboard[i][aim].blue_val;
			}
			else
			{
				max = myboard[i + 1][aim - 1].blue_down.second + myboard[i][aim].blue_val;
				min = myboard[i][aim - 1].blue_down.second + myboard[i][aim].blue_val;
			}
			if (myboard[i][aim].blue_val < inf)
			{
				if (myboard[i][aim].blue_down.first > max)
				{
					myboard[i][aim].blue_down.first = min;
					myboard[i][aim].blue_down.second = max;
				}
				else if (myboard[i][aim].blue_down.first > min)
				{
					myboard[i][aim].blue_down.second = myboard[i][aim].blue_down.first;
					myboard[i][aim].blue_down.first = min;
				}
				else if (myboard[i][aim].blue_down.second > min)
				{
					myboard[i][aim].blue_down.second = min;
				}
			}
		}
		if (myboard[SIZE - 1][aim].blue_down.first > myboard[SIZE - 1][aim - 1].blue_down.second + myboard[SIZE - 1][aim].blue_val)
		{
			myboard[SIZE - 1][aim].blue_down.second = myboard[SIZE - 1][aim].blue_down.first;
			myboard[SIZE - 1][aim].blue_down.first = myboard[SIZE - 1][aim - 1].blue_down.second + myboard[SIZE - 1][aim].blue_val;
		}
		else if (myboard[SIZE - 1][aim].blue_down.second > myboard[SIZE - 1][aim - 1].blue_down.second + myboard[SIZE - 1][aim].blue_val)
		{
			myboard[SIZE - 1][aim].blue_down.second = myboard[SIZE - 1][aim - 1].blue_down.second + myboard[SIZE - 1][aim].blue_val;
		}
	}

	blue_to_down_to_right(aim);

	int back = aim - 1;
	int isback = blue_twodis_to_down_to_down(back);
	if (isback == 0)
		return aim + 1;
	while (isback != 0)
	{
		back--;
		isback = blue_twodis_to_down_to_down(back);
	}
	return back;
}

int blue_to_down_to_right(int aim)
{
	int flag = 0;
	for (int j = 0; j < 2; j++)
	{
		for (int i = 0; i < SIZE;)
		{
			int changflag = 0;
			if (i == 0)
			{
				if (myboard[i][aim].blue_down.first > myboard[i + 1][aim].blue_down.second + myboard[i][aim].blue_val)
				{
					myboard[i][aim].blue_down.second = myboard[i][aim].blue_down.first;
					myboard[i][aim].blue_down.first = myboard[i + 1][aim].blue_down.second + myboard[i][aim].blue_val;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[i][aim].blue_down.second > myboard[i + 1][aim].blue_down.second + myboard[i][aim].blue_val)
				{
					myboard[i][aim].blue_down.second = myboard[i + 1][aim].blue_down.second + myboard[i][aim].blue_val;
					changflag = 1;
					flag = 1;
				}
			}
			else if (i == SIZE - 1)
			{
				if (myboard[i][aim].blue_down.first > myboard[i - 1][aim].blue_down.second + myboard[i][aim].blue_val)
				{
					myboard[i][aim].blue_down.second = myboard[i][aim].blue_down.first;
					myboard[i][aim].blue_down.first = myboard[i - 1][aim].blue_down.second + myboard[i][aim].blue_val;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[i][aim].blue_down.second > myboard[i - 1][aim].blue_down.second + myboard[i][aim].blue_val)
				{
					myboard[i][aim].blue_down.second = myboard[i - 1][aim].blue_down.second + myboard[i][aim].blue_val;
					changflag = 1;
					flag = 1;
				}
			}
			else
			{
				int min = 0;
				int max = 0;
				if (myboard[i - 1][aim].blue_down.second + myboard[i][aim].blue_val > myboard[i + 1][aim].blue_down.second + myboard[i][aim].blue_val)
				{
					max = myboard[i - 1][aim].blue_down.second + myboard[i][aim].blue_val;
					min = myboard[i + 1][aim].blue_down.second + myboard[i][aim].blue_val;
				}
				else
				{
					max = myboard[i + 1][aim].blue_down.second + myboard[i][aim].blue_val;
					min = myboard[i - 1][aim].blue_down.second + myboard[i][aim].blue_val;
				}
				if (myboard[i][aim].blue_down.first > max)
				{
					myboard[i][aim].blue_down.first = min;
					myboard[i][aim].blue_down.second = max;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[i][aim].blue_down.first > min)
				{
					myboard[i][aim].blue_down.second = myboard[i][aim].blue_down.first;
					myboard[i][aim].blue_down.first = min;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[i][aim].blue_down.second > min)
				{
					myboard[i][aim].blue_down.second = min;
					changflag = 1;
					flag = 1;
				}
			}
			if (changflag == 1 && i != 0)
				i--;
			else
				i++;
		}
	}
	return flag;
}

int blue_twodis_to_down_to_down(int aim)
{
	if (aim <= 0)
		return 0;
	if (aim == SIZE - 1)
		return 0;
	int changflag = 0;
	if (myboard[0][aim].blue_down.first > myboard[0][aim + 1].blue_down.second + myboard[0][aim].blue_val)
	{
		myboard[0][aim].blue_down.second = myboard[0][aim].blue_down.first;
		myboard[0][aim].blue_down.first = myboard[0][aim + 1].blue_down.second + myboard[0][aim].blue_val;
		changflag = 1;
	}
	else if (myboard[0][aim].blue_down.second > myboard[0][aim + 1].blue_down.second + myboard[0][aim].blue_val)
	{
		myboard[0][aim].blue_down.second = myboard[0][aim + 1].blue_down.second + myboard[0][aim].blue_val;
		changflag = 1;
	}
	for (int i = 1; i < SIZE; i++)
	{
		int min = 0;
		int max = 0;
		if (myboard[i][aim + 1].blue_down.second + myboard[i][aim].blue_val > myboard[i - 1][aim + 1].blue_down.second + myboard[i][aim].blue_val)
		{
			max = myboard[i][aim + 1].blue_down.second + myboard[i][aim].blue_val;
			min = myboard[i - 1][aim + 1].blue_down.second + myboard[i][aim].blue_val;
		}
		else
		{
			max = myboard[i - 1][aim + 1].blue_down.second + myboard[i][aim].blue_val;
			min = myboard[i][aim + 1].blue_down.second + myboard[i][aim].blue_val;
		}
		if (myboard[i][aim].blue_val < inf)
		{
			if (myboard[i][aim].blue_down.first > max)
			{
				myboard[i][aim].blue_down.first = min;
				myboard[i][aim].blue_down.second = max;
				changflag = 1;
			}
			else if (myboard[i][aim].blue_down.first > min)
			{
				myboard[i][aim].blue_down.second = myboard[i][aim].blue_down.first;
				myboard[i][aim].blue_down.first = min;
				changflag = 1;
			}
			else if (myboard[i][aim].blue_down.second > min)
			{
				myboard[i][aim].blue_down.second = min;
				changflag = 1;
			}
		}
	}
	changflag += blue_to_down_to_right(aim);
	return changflag;
}

int blue_twodis_to_up(int aim)
{
	if (aim == SIZE - 1)
	{
		for (int i = 0; i < SIZE; i++)
		{
			if (myboard[i][aim].blue_val < inf && myboard[i][aim].blue_val > 0)
			{
				myboard[i][aim].blue_up.first = 0;
				myboard[i][aim].blue_up.second = 1;
			}
			else if (myboard[i][aim].blue_val == 0)
			{
				myboard[i][aim].blue_up.first = 0;
				myboard[i][aim].blue_up.second = 0;
			}
		}
	}
	else
	{
		if (myboard[0][aim].blue_up.first > myboard[0][aim + 1].blue_up.second + myboard[0][aim].blue_val)
		{
			myboard[0][aim].blue_up.second = myboard[0][aim].blue_up.first;
			myboard[0][aim].blue_up.first = myboard[0][aim + 1].blue_up.second + myboard[0][aim].blue_val;
		}
		else if (myboard[0][aim].blue_up.second > myboard[0][aim - 1].blue_up.second + myboard[0][aim].blue_val)
		{
			myboard[0][aim].blue_up.second = myboard[0][aim - 1].blue_up.second + myboard[0][aim].blue_val;
		}
		for (int i = 1; i < SIZE; i++)
		{
			int min = 0;
			int max = 0;
			if (myboard[i][aim + 1].blue_up.second + myboard[i][aim].blue_val > myboard[i - 1][aim + 1].blue_up.second + myboard[i][aim].blue_val)
			{
				max = myboard[i][aim + 1].blue_up.second + myboard[i][aim].blue_val;
				min = myboard[i - 1][aim + 1].blue_up.second + myboard[i][aim].blue_val;
			}
			else
			{
				max = myboard[i - 1][aim + 1].blue_up.second + myboard[i][aim].blue_val;
				min = myboard[i][aim + 1].blue_up.second + myboard[i][aim].blue_val;
			}
			if (myboard[i][aim].blue_up.first > max)
			{
				myboard[i][aim].blue_up.first = min;
				myboard[i][aim].blue_up.second = max;
			}
			else if (myboard[i][aim].blue_up.first > min)
			{
				myboard[i][aim].blue_up.second = myboard[i][aim].blue_up.first;
				myboard[i][aim].blue_up.first = min;
			}
			else if (myboard[i][aim].blue_up.second > min)
			{
				myboard[i][aim].blue_up.second = min;
			}
		}
	}

	blue_to_up_to_left(aim);

	int back = aim + 1;
	int isback = blue_twodis_to_up_to_up(back);
	if (isback == 0)
		return aim - 1;
	while (isback != 0)
	{
		back++;
		isback = blue_twodis_to_up_to_up(back);
	}
	return back;
}

int blue_to_up_to_left(int aim)
{
	int flag = 0;
	for (int j = 0; j < 2; j++)
	{
		for (int i = 0; i < SIZE;)
		{
			int changflag = 0;;
			if (i == 0)
			{
				if (myboard[i][aim].blue_up.first > myboard[i + 1][aim].blue_up.second + myboard[i][aim].blue_val)
				{
					myboard[i][aim].blue_up.second = myboard[i][aim].blue_up.first;
					myboard[i][aim].blue_up.first = myboard[i + 1][aim].blue_up.second + myboard[i][aim].blue_val;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[i][aim].blue_up.second > myboard[i + 1][aim].blue_up.second + myboard[i][aim].blue_val)
				{
					myboard[i][aim].blue_up.second = myboard[i + 1][aim].blue_up.second + myboard[i][aim].blue_val;
					changflag = 1;
					flag = 1;
				}
			}
			else if (i == SIZE - 1)
			{
				if (myboard[i][aim].blue_up.first > myboard[i - 1][aim].blue_up.second + myboard[i][aim].blue_val)
				{
					myboard[i][aim].blue_up.second = myboard[i][aim].blue_up.first;
					myboard[i][aim].blue_up.first = myboard[i - 1][aim].blue_up.second + myboard[i][aim].blue_val;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[i][aim].blue_up.second > myboard[i - 1][aim].blue_up.second + myboard[i][aim].blue_val)
				{
					myboard[i][aim].blue_up.second = myboard[i - 1][aim].blue_up.second + myboard[i][aim].blue_val;
					changflag = 1;
					flag = 1;
				}
			}
			else
			{
				int min = 0;
				int max = 0;
				if (myboard[i - 1][aim].blue_up.second + myboard[i][aim].blue_val > myboard[i + 1][aim].blue_up.second + myboard[i][aim].blue_val)
				{
					max = myboard[i - 1][aim].blue_up.second + myboard[i][aim].blue_val;
					min = myboard[i + 1][aim].blue_up.second + myboard[i][aim].blue_val;
				}
				else
				{
					max = myboard[i + 1][aim].blue_up.second + myboard[i][aim].blue_val;
					min = myboard[i - 1][aim].blue_up.second + myboard[i][aim].blue_val;
				}
				if (myboard[i][aim].blue_up.first > max)
				{
					myboard[i][aim].blue_up.first = min;
					myboard[i][aim].blue_up.second = max;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[i][aim].blue_up.first > min)
				{
					myboard[i][aim].blue_up.second = myboard[i][aim].blue_up.first;
					myboard[i][aim].blue_up.first = min;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[i][aim].blue_up.second > min)
				{
					myboard[i][aim].blue_up.second = min;
					changflag = 1;
					flag = 1;
				}
			}
			if (changflag == 1 && i != 0)
				i--;
			else
				i++;
		}
	}
	return flag;
}

int blue_twodis_to_up_to_up(int aim)
{
	if (aim == 0)
		return 0;
	if (aim >= SIZE - 1)
		return 0;
	int changflag = 0;
	if (myboard[SIZE - 1][aim].blue_up.first > myboard[SIZE - 1][aim - 1].blue_up.second + myboard[SIZE - 1][aim].blue_val)
	{
		myboard[SIZE - 1][aim].blue_up.second = myboard[SIZE - 1][aim].blue_up.first;
		myboard[SIZE - 1][aim].blue_up.first = myboard[SIZE - 1][aim - 1].blue_up.second + myboard[SIZE - 1][aim].blue_val;
		changflag = 1;
	}
	else if (myboard[SIZE - 1][aim].blue_up.second > myboard[SIZE - 1][aim - 1].blue_up.second + myboard[SIZE - 1][aim].blue_val)
	{
		myboard[SIZE - 1][aim].blue_up.second = myboard[SIZE - 1][aim - 1].blue_up.second + myboard[SIZE - 1][aim].blue_val;
		changflag = 1;
	}
	for (int i = 0; i < SIZE - 1; i++)
	{
		int min = 0;
		int max = 0;
		if (myboard[i][aim - 1].blue_up.second + myboard[i][aim].blue_val > myboard[i + 1][aim - 1].blue_up.second + myboard[i][aim].blue_val)
		{
			max = myboard[i][aim - 1].blue_up.second + myboard[i][aim].blue_val;
			min = myboard[i + 1][aim - 1].blue_up.second + myboard[i][aim].blue_val;
		}
		else
		{
			max = myboard[i + 1][aim - 1].blue_up.second + myboard[i][aim].blue_val;
			min = myboard[i][aim - 1].blue_up.second + myboard[i][aim].blue_val;
		}
		if (myboard[i][aim].blue_up.first > max)
		{
			myboard[i][aim].blue_up.first = min;
			myboard[i][aim].blue_up.second = max;
			changflag = 1;
		}
		else if (myboard[i][aim].blue_up.first > min)
		{
			myboard[i][aim].blue_up.second = myboard[i][aim].blue_up.first;
			myboard[i][aim].blue_up.first = min;
			changflag = 1;
		}
		else if (myboard[i][aim].blue_up.second > min)
		{
			myboard[i][aim].blue_up.second = min;
			changflag = 1;
		}
	}
	changflag += blue_to_up_to_left(aim);
	return changflag;
}

int red_twodis_to_left(int aim)
{
	if (aim == 0)
	{
		for (int i = 0; i < SIZE; i++)
		{
			if (myboard[aim][i].red_val < inf && myboard[aim][i].red_val > 0)
			{
				myboard[aim][i].red_left.first = 0;
				myboard[aim][i].red_left.second = 1;
			}
			else if (myboard[aim][i].red_val == 0)
			{
				myboard[aim][i].red_left.first = 0;
				myboard[aim][i].red_left.second = 0;
			}
		}
	}
	else
	{
		for (int i = 0; i < SIZE - 1; i++)
		{
			int min = 0;
			int max = 0;
			if (myboard[aim - 1][i].red_left.second + myboard[aim][i].red_val > myboard[aim - 1][i + 1].red_left.second + myboard[aim][i].red_val)
			{
				max = myboard[aim - 1][i].red_left.second + myboard[aim][i].red_val;
				min = myboard[aim - 1][i + 1].red_left.second + myboard[aim][i].red_val;
			}
			else
			{
				max = myboard[aim - 1][i + 1].red_left.second + myboard[aim][i].red_val;
				min = myboard[aim - 1][i].red_left.second + myboard[aim][i].red_val;
			}
			if (myboard[aim][i].red_left.first > max)
			{
				myboard[aim][i].red_left.first = min;
				myboard[aim][i].red_left.second = max;
			}
			else if (myboard[aim][i].red_left.first > min)
			{
				myboard[aim][i].red_left.second = myboard[aim][i].red_left.first;
				myboard[aim][i].red_left.first = min;
			}
			else if (myboard[aim][i].red_left.first > min)
			{
				myboard[aim][i].red_left.second = min;
			}
		}
		if (myboard[aim][SIZE - 1].red_left.first > myboard[aim - 1][SIZE - 1].red_left.second + myboard[aim][SIZE - 1].red_val)
		{
			myboard[aim][SIZE - 1].red_left.second = myboard[aim][SIZE - 1].red_left.first;
			myboard[aim][SIZE - 1].red_left.first = myboard[aim - 1][SIZE - 1].red_left.second + myboard[aim][SIZE - 1].red_val;
		}
		else if (myboard[aim][SIZE - 1].red_left.second > myboard[aim - 1][SIZE - 1].red_left.second + myboard[aim][SIZE - 1].red_val)
		{
			myboard[aim][SIZE - 1].red_left.second = myboard[aim - 1][SIZE - 1].red_left.second + myboard[aim][SIZE - 1].red_val;
		}
	}

	red_to_left_to_up(aim);

	int back = aim - 1;
	int isback = red_twodis_to_left_to_left(back);
	if (isback == 0)
		return aim + 1;
	while (isback != 0)
	{
		back--;
		isback = red_twodis_to_left_to_left(back);
	}
	return back;
}

int red_to_left_to_up(int aim)
{
	int flag = 0;
	for (int j = 0; j < 2; j++)
	{
		for (int i = 0; i < SIZE;)
		{
			int changflag = 0;
			if (i == 0)
			{
				if (myboard[aim][i].red_left.first > myboard[aim][i + 1].red_left.second + myboard[aim][i].red_val)
				{
					myboard[aim][i].red_left.second = myboard[aim][i].red_left.first;
					myboard[aim][i].red_left.first = myboard[aim][i + 1].red_left.second + myboard[aim][i].red_val;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[aim][i].red_left.second > myboard[aim][i + 1].red_left.second + myboard[aim][i].red_val)
				{
					myboard[aim][i].red_left.second = myboard[aim][i + 1].red_left.second + myboard[aim][i].red_val;
					changflag = 1;
					flag = 1;
				}
			}
			else if (i == SIZE - 1)
			{
				if (myboard[aim][i].red_left.first > myboard[aim][i - 1].red_left.second + myboard[aim][i].red_val)
				{
					myboard[aim][i].red_left.second = myboard[aim][i].red_left.first;
					myboard[aim][i].red_left.first = myboard[aim][i - 1].red_left.second + myboard[aim][i].red_val;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[aim][i].red_left.second > myboard[aim][i - 1].red_left.second + myboard[aim][i].red_val)
				{
					myboard[aim][i].red_left.second = myboard[aim][i - 1].red_left.second + myboard[aim][i].red_val;
					changflag = 1;
					flag = 1;
				}
			}
			else
			{
				int min = 0;
				int max = 0;
				if (myboard[aim][i - 1].red_left.second + myboard[aim][i].red_val > myboard[aim][i + 1].red_left.second + myboard[aim][i].red_val)
				{
					max = myboard[aim][i - 1].red_left.second + myboard[aim][i].red_val;
					min = myboard[aim][i + 1].red_left.second + myboard[aim][i].red_val;
				}
				else
				{
					max = myboard[aim][i + 1].red_left.second + myboard[aim][i].red_val;
					min = myboard[aim][i - 1].red_left.second + myboard[aim][i].red_val;
				}
				if (myboard[aim][i].red_left.first > max)
				{
					myboard[aim][i].red_left.first = min;
					myboard[aim][i].red_left.second = max;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[aim][i].red_left.first > min)
				{
					myboard[aim][i].red_left.second = myboard[aim][i].red_left.first;
					myboard[aim][i].red_left.first = min;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[aim][i].red_left.second > min)
				{
					myboard[aim][i].red_left.second = min;
					changflag = 1;
					flag = 1;
				}
			}
			if (changflag == 1 && i != 0)
				i--;
			else
				i++;
		}
	}
	return flag;
}

int red_twodis_to_left_to_left(int aim)
{
	if (aim <= 0)
		return 0;
	if (aim == SIZE - 1)
		return 0;
	int changflag = 0;
	if (myboard[aim][0].red_val < inf)
	{
		if (myboard[aim][0].red_left.first > myboard[aim + 1][0].red_left.second + myboard[aim][0].red_val)
		{
			myboard[aim][0].red_left.second = myboard[aim][0].red_left.first;
			myboard[aim][0].red_left.first = myboard[aim + 1][0].red_left.second + myboard[aim][0].red_val;
			changflag = 1;
		}
		else if (myboard[aim][0].red_left.second > myboard[aim + 1][0].red_left.second + myboard[aim][0].red_val)
		{
			myboard[aim][0].red_left.second = myboard[aim + 1][0].red_left.second + myboard[aim][0].red_val;
			changflag = 1;
		}
	}
	for (int i = 1; i < SIZE; i++)
	{
		int min = 0;
		int max = 0;
		if (myboard[aim + 1][i].red_left.second + myboard[aim][i].red_val > myboard[aim + 1][i - 1].red_left.second + myboard[aim][i].red_val)
		{
			max = myboard[aim + 1][i].red_left.second + myboard[aim][i].red_val;
			min = myboard[aim + 1][i - 1].red_left.second + myboard[aim][i].red_val;
		}
		else
		{
			max = myboard[aim + 1][i - 1].red_left.second + myboard[aim][i].red_val;
			min = myboard[aim + 1][i].red_left.second + myboard[aim][i].red_val;
		}
		if (myboard[aim][i].red_left.first > max)
		{
			myboard[aim][i].red_left.first = min;
			myboard[aim][i].red_left.second = max;
			changflag = 1;
		}
		else if (myboard[aim][i].red_left.first > min)
		{
			myboard[aim][i].red_left.second = myboard[aim][i].red_left.first;
			myboard[aim][i].red_left.first = min;
			changflag = 1;
		}
		else if (myboard[aim][i].red_left.second > min)
		{
			myboard[aim][i].red_left.second = min;
			changflag = 1;
		}
	}
	changflag += red_to_left_to_up(aim);
	return changflag;
}

int red_twodis_to_right(int aim)
{
	if (aim == SIZE - 1)
	{
		for (int i = 0; i < SIZE; i++)
		{
			if (myboard[aim][i].red_val < inf && myboard[aim][i].red_val > 0)
			{
				myboard[aim][i].red_right.first = 0;
				myboard[aim][i].red_right.second = 1;
			}
			else if (myboard[aim][i].red_val == 0)
			{
				myboard[aim][i].red_right.first = 0;
				myboard[aim][i].red_right.second = 0;
			}
		}
	}
	else
	{
		if (myboard[aim][0].red_right.first > myboard[aim + 1][0].red_right.second + myboard[aim][0].red_val)
		{
			myboard[aim][0].red_right.second = myboard[aim][0].red_right.first;
			myboard[aim][0].red_right.first = myboard[aim + 1][0].red_right.second + myboard[aim][0].red_val;
		}
		else if (myboard[aim][0].red_right.second > myboard[aim + 1][0].red_right.second + myboard[aim][0].red_val)
		{
			myboard[aim][0].red_right.second = myboard[aim + 1][0].red_right.second + myboard[aim][0].red_val;
		}
		for (int i = 1; i <= SIZE - 1; i++)
		{
			int min = 0;
			int max = 0;
			if (myboard[aim + 1][i].red_right.second + myboard[aim][i].red_val > myboard[aim + 1][i - 1].red_right.second + myboard[aim][i].red_val)
			{
				max = myboard[aim + 1][i].red_right.second + myboard[aim][i].red_val;
				min = myboard[aim + 1][i - 1].red_right.second + myboard[aim][i].red_val;
			}
			else
			{
				max = myboard[aim + 1][i - 1].red_right.second + myboard[aim][i].red_val;
				min = myboard[aim + 1][i].red_right.second + myboard[aim][i].red_val;
			}
			if (myboard[aim][i].red_right.first > max)
			{
				myboard[aim][i].red_right.first = min;
				myboard[aim][i].red_right.second = max;
			}
			else if (myboard[aim][i].red_right.first > min)
			{
				myboard[aim][i].red_right.second = myboard[aim][i].red_right.first;
				myboard[aim][i].red_right.first = min;
			}
			else if (myboard[aim][i].red_right.first > min)
			{
				myboard[aim][i].red_right.second = min;
			}
		}
	}

	red_to_right_to_down(aim);

	int back = aim + 1;
	int isback = red_twodis_to_right_to_right(back);
	if (isback == 0)
		return aim - 1;
	while (isback != 0)
	{
		back++;
		isback = red_twodis_to_right_to_right(back);
	}
	return back;
}

int red_to_right_to_down(int aim)
{
	int flag = 0;
	for (int j = 0; j < 2; j++)
	{
		for (int i = 0; i < SIZE;)
		{
			int changflag = 0;
			if (i == 0)
			{
				if (myboard[aim][i].red_right.first > myboard[aim][i + 1].red_right.second + myboard[aim][i].red_val)
				{
					myboard[aim][i].red_right.second = myboard[aim][i].red_right.first;
					myboard[aim][i].red_right.first = myboard[aim][i + 1].red_right.second + myboard[aim][i].red_val;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[aim][i].red_right.second > myboard[aim][i + 1].red_right.second + myboard[aim][i].red_val)
				{
					myboard[aim][i].red_right.second = myboard[aim][i + 1].red_right.second + myboard[aim][i].red_val;
					changflag = 1;
					flag = 1;
				}
			}
			else if (i == SIZE - 1)
			{
				if (myboard[aim][i].red_right.first > myboard[aim][i - 1].red_right.second + myboard[aim][i].red_val)
				{
					myboard[aim][i].red_right.second = myboard[aim][i].red_right.first;
					myboard[aim][i].red_right.first = myboard[aim][i - 1].red_right.second + myboard[aim][i].red_val;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[aim][i].red_right.second > myboard[aim][i - 1].red_right.second + myboard[aim][i].red_val)
				{
					myboard[aim][i].red_right.second = myboard[aim][i - 1].red_right.second + myboard[aim][i].red_val;
					changflag = 1;
					flag = 1;
				}
			}
			else
			{
				int min = 0;
				int max = 0;
				if (myboard[aim][i - 1].red_right.second + myboard[aim][i].red_val > myboard[aim][i + 1].red_right.second + myboard[aim][i].red_val)
				{
					max = myboard[aim][i - 1].red_right.second + myboard[aim][i].red_val;
					min = myboard[aim][i + 1].red_right.second + myboard[aim][i].red_val;
				}
				else
				{
					max = myboard[aim][i + 1].red_right.second + myboard[aim][i].red_val;
					min = myboard[aim][i - 1].red_right.second + myboard[aim][i].red_val;
				}
				if (myboard[aim][i].red_right.first > max)
				{
					myboard[aim][i].red_right.first = min;
					myboard[aim][i].red_right.second = max;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[aim][i].red_right.first > min)
				{
					myboard[aim][i].red_right.second = myboard[aim][i].red_right.first;
					myboard[aim][i].red_right.first = min;
					changflag = 1;
					flag = 1;
				}
				else if (myboard[aim][i].red_right.second > min)
				{
					myboard[aim][i].red_right.second = min;
					changflag = 1;
					flag = 1;
				}
			}
			if (changflag == 1 && i != 0)
				i--;
			else
				i++;
		}
	}
	return flag;
}

int red_twodis_to_right_to_right(int aim)
{
	if (aim == 0)
		return 0;
	if (aim >= SIZE - 1)
		return 0;
	int changflag = 0;
	if (myboard[aim][SIZE - 1].red_right.first > myboard[aim - 1][SIZE - 1].red_right.second + myboard[aim][SIZE - 1].red_val)
	{
		myboard[aim][SIZE - 1].red_right.second = myboard[aim][SIZE - 1].red_right.first;
		myboard[aim][SIZE - 1].red_right.first = myboard[aim - 1][SIZE - 1].red_right.second + myboard[aim][SIZE - 1].red_val;
		changflag = 1;
	}
	else if (myboard[aim][SIZE - 1].red_right.second > myboard[aim - 1][SIZE - 1].red_right.second + myboard[aim][SIZE - 1].red_val)
	{
		myboard[aim][SIZE - 1].red_right.second = myboard[aim - 1][SIZE - 1].red_right.second + myboard[aim][SIZE - 1].red_val;
		changflag = 1;
	}
	for (int i = 0; i < SIZE - 1; i++)
	{
		int min = 0;
		int max = 0;
		if (myboard[aim - 1][i].red_right.second + myboard[aim][i].red_val > myboard[aim - 1][i + 1].red_right.second + myboard[aim][i].red_val)
		{
			max = myboard[aim - 1][i].red_right.second + myboard[aim][i].red_val;
			min = myboard[aim - 1][i + 1].red_right.second + myboard[aim][i].red_val;
		}
		else
		{
			max = myboard[aim - 1][i + 1].red_right.second + myboard[aim][i].red_val;
			min = myboard[aim - 1][i].red_right.second + myboard[aim][i].red_val;
		}
		if (myboard[aim][i].red_right.first > max)
		{
			myboard[aim][i].red_right.first = min;
			myboard[aim][i].red_right.second = max;
			changflag = 1;
		}
		else if (myboard[aim][i].red_right.first > min)
		{
			myboard[aim][i].red_right.second = myboard[aim][i].red_right.first;
			myboard[aim][i].red_right.first = min;
			changflag = 1;
		}
		else if (myboard[aim][i].red_right.second > min)
		{
			myboard[aim][i].red_right.second = min;
			changflag = 1;
		}
	}
	changflag += red_to_right_to_down(aim);
	return changflag;
}

void updata()
{
	int aim = 0;
	while (aim < SIZE)
	{
		aim = blue_twodis_to_down(aim);
		//		cout << 1 << endl;
	}
	aim--;
	while (aim >= 0)
	{
		aim = blue_twodis_to_up(aim);
		//		cout << 2 << endl;
	}
	aim++;
	while (aim < SIZE)
	{
		aim = red_twodis_to_left(aim);
		//		cout << 3 << endl;
	}
	aim--;
	while (aim >= 0)
	{
		aim = red_twodis_to_right(aim);
		//		cout << 4 << endl;
	}
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			myboard[i][j].bluedistance = myboard[i][j].blue_down.second + myboard[i][j].blue_up.second;
			myboard[i][j].reddistance = myboard[i][j].red_left.second + myboard[i][j].red_right.second;
		}
	}
}

int get_pot(int color)
{
	int bluemin, redmin, bluenum, rednum;
	bluemin = redmin = inf + inf;
	bluenum = rednum = 0;
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			if (myboard[i][j].bluedistance == bluemin)
			{
				bluenum++;
			}
			else if (myboard[i][j].bluedistance < bluemin)
			{
				bluemin = myboard[i][j].bluedistance;
				bluenum = 1;
			}
			if (myboard[i][j].reddistance == redmin)
			{
				rednum++;
			}
			else if (myboard[i][j].reddistance < redmin)
			{
				redmin = myboard[i][j].reddistance;
				rednum = 1;
			}
		}
	}
	int M = 100;
	int pot = 0;
	pot = M * (redmin - bluemin) - (rednum - bluenum);     //to blue better
	if (color == 1)
		return pot;
	else
		return 50000 - pot;
}

xgznode** to_get_twodis_best_point()
{

	xgznode_num = 4;


	int my = 0; //my = 1  ->   red now
	if (Current_board[1][2] == color )
	{
		my = 1;
	}
	else
	{
		my = 0;
	}


	make_myboard();
	int pot[SIZE][SIZE] = { 0 };
	//int** pot = new int* [SIZE];
	//for (int i = 0; i < SIZE; i++)
	//{
	//	pot[i] = new int[SIZE];
	//	for (int j = 0; j < SIZE; j++)
	//	{
	//		pot[i][j] = 0;
	//	}
	//}
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			if (myboard[i][j].fill != 1 && my == 1)
			{
				myboard[i][j].tofill(1);
				updata();
				pot[i][j] = get_pot(my);
				make_myboard();
			}
			else if (myboard[i][j].fill != 1 && my == 0)
			{
				myboard[i][j].tofill(-1);
				//				cout << i << ' ' << j << endl;
				updata();
				pot[i][j] = get_pot(my);
				make_myboard();
			}
		}
	}
	vector <xgznode> aim;
	for (int i = 0; i < 4; i++)
	{
		xgznode temp;
		aim.push_back(temp);
	}

	/*
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			if (myboard[i][j]->fill == 0 && pot[i][j] > max0)
			{
				max3 = max2;
				max2 = max1;
				max1 = max0;
				max0 = pot[i][j];
				aim[3] = aim[2];
				aim[2] = aim[1];
				aim[1] = aim[0];
				aim[0] = myboard[i][j];
			}
			else if (myboard[i][j]->fill == 0 && pot[i][j] > max1)
			{
				max3 = max2;
				max2 = max1;
				max1 = pot[i][j];
				aim[3] = aim[2];
				aim[2] = aim[1];
				aim[1] = myboard[i][j];
			}
			else if (myboard[i][j]->fill == 0 && pot[i][j] > max2)
			{
				max3 = max2;
				max2 = pot[i][j];
				aim[3] = aim[2];
				aim[2] = myboard[i][j];
			}
			else if (myboard[i][j]->fill == 0 && pot[i][j] > max3)
			{
				max3 = pot[i][j];
				aim[3] = myboard[i][j];
			}
		}
	}
	*/
	int min0, min1, min2, min3, min4, min5, min6, min7, min8, min9;
	min0 = min1 = min2 = min3 = min4 = min5 = min6 = min7 = min8 = min9 = 1000000;
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			if (myboard[i][j].fill == 0 && pot[i][j] < min0)
			{
				min9 = min8;
				min8 = min7;
				min7 = min6;
				min6 = min5;
				min5 = min4;
				min4 = min3;
				min3 = min2;
				min2 = min1;
				min1 = min0;
				min0 = pot[i][j];
				aim[9] = aim[8];
				aim[8] = aim[7];
				aim[7] = aim[6];
				aim[6] = aim[5];
				aim[5] = aim[4];
				aim[4] = aim[3];
				aim[3] = aim[2];
				aim[2] = aim[1];
				aim[1] = aim[0];
				aim[0] = myboard[i][j];
			}
			else if (myboard[i][j].fill == 0 && pot[i][j] < min1)
			{
				min9 = min8;
				min8 = min7;
				min7 = min6;
				min6 = min5;
				min5 = min4;
				min4 = min3;
				min3 = min2;
				min2 = min1;
				min1 = pot[i][j];
				aim[9] = aim[8];
				aim[8] = aim[7];
				aim[7] = aim[6];
				aim[6] = aim[5];
				aim[5] = aim[4];
				aim[4] = aim[3];
				aim[3] = aim[2];
				aim[2] = aim[1];
				aim[1] = myboard[i][j];
			}
			else if (myboard[i][j].fill == 0 && pot[i][j] < min2)
			{
				min9 = min8;
				min8 = min7;
				min7 = min6;
				min6 = min5;
				min5 = min4;
				min4 = min3;
				min3 = min2;
				min2 = pot[i][j];
				aim[9] = aim[8];
				aim[8] = aim[7];
				aim[7] = aim[6];
				aim[6] = aim[5];
				aim[5] = aim[4];
				aim[4] = aim[3];
				aim[3] = aim[2];
				aim[2] =myboard[i][j];
			}
			else if (myboard[i][j].fill == 0 && pot[i][j] < min3)
			{
				min9 = min8;
				min8 = min7;
				min7 = min6;
				min6 = min5;
				min5 = min4;
				min4 = min3;
				min3 = pot[i][j];
				aim[9] = aim[8];
				aim[8] = aim[7];
				aim[7] = aim[6];
				aim[6] = aim[5];
				aim[5] = aim[4];
				aim[4] = aim[3];
				aim[3] = myboard[i][j];
			}
			else if (myboard[i][j].fill == 0 && pot[i][j] < min4)
			{
				min9 = min8;
				min8 = min7;
				min7 = min6;
				min6 = min5;
				min5 = min4;
				min4 = pot[i][j];
				aim[9] = aim[8];
				aim[8] = aim[7];
				aim[7] = aim[6];
				aim[6] = aim[5];
				aim[5] = aim[4];
				aim[4] = myboard[i][j];
			}
			else if (myboard[i][j].fill == 0 && pot[i][j] < min5)
			{
				min9 = min8;
				min8 = min7;
				min7 = min6;
				min6 = min5;
				min5 = pot[i][j];
				aim[9] = aim[8];
				aim[8] = aim[7];
				aim[7] = aim[6];
				aim[6] = aim[5];
				aim[5] =  myboard[i][j];
			}
			else if (myboard[i][j].fill == 0 && pot[i][j] < min6)
			{
				min9 = min8;
				min8 = min7;
				min7 = min6;
				min6 = pot[i][j];
				aim[9] = aim[8];
				aim[8] = aim[7];
				aim[7] = aim[6];
				aim[6] = myboard[i][j];
			}
			else if (myboard[i][j].fill == 0 && pot[i][j] < min7)
			{
				min9 = min8;
				min8 = min7;
				min7 = pot[i][j];
				aim[9] = aim[8];
				aim[8] = aim[7];
				aim[7] = myboard[i][j];
			}
			else if (myboard[i][j].fill == 0 && pot[i][j] < min8)
			{
				min9 = min8;
				min8 = pot[i][j];
				aim[9] = aim[8];
				aim[8] = myboard[i][j];
			}
			else if (myboard[i][j].fill == 0 && pot[i][j] < min9)
			{
				min9 = pot[i][j];
				aim[9] = myboard[i][j];
			}
		}
	}
	int num = 0;
	xgznode** back = new xgznode * [xgznode_num];
	for (int i = 0; i < xgznode_num; i++)
	{
		if (aim[i].i != -1 && myboard[aim[i].i][aim[i].j].fill == 0)
		{
			back[i] = &myboard[aim[i].i][aim[i].j];
			num++;
		}
		//cout << back[i]->i << ' ' << back[i]->j << endl;
	}

	xgznode_num = num;


	//for (int i = 0; i < num; i++)
	//{
	//	cout << back[i]->i << ' ' << back[i]->j << endl;
	//}
	//cout << endl;
	// 
	// 
	// 
	//for (int i = 0; i < SIZE; i++)
	//{
	//	for (int j = 0; j < SIZE; j++)
	//	{
	//		cout << pot[i][j] << ' ';
	//	}
	//	cout << endl;
	//}

	//nowtime = clock();
	//cout << nowtime - sttime;
	return back;
}









int is_win()				//我方赢了返回1，对方赢了返回-1，未结束返回0
{
	if (Current_board[1][2] == 1)			//我方先手
	{
		if (union_find_father(&Current_boundary[0]) == union_find_father(&Current_boundary[2]))
			return 1;
		else if (union_find_father(&Current_boundary[1]) == union_find_father(&Current_boundary[3]))
			return -1;
		else
			return 0;
	}
	else if (Current_board[1][2] == -1)			//对方先手
	{
		if (union_find_father(&Current_boundary[0]) == union_find_father(&Current_boundary[2]))
			return -1;
		else if (union_find_father(&Current_boundary[1]) == union_find_father(&Current_boundary[3]))
			return 1;
		else
			return 0;
	}
}

void union_find()			//棋盘并查集初始化
{
	if (Current_board[1][2] == 1)			//我方先手，从i/x == 0到 i/x == 10
	{
		for (int i = 0; i < 11; i++)
		{
			for (int j = 0; j < 11; j++)
			{
				union_board[i][j].father = &union_board[i][j];
				union_board[i][j].x = i;
				union_board[i][j].y = j;
			}
		}
		for (int i = 0; i < 11; i++)
		{
			for (int j = 0; j < 11; j++)
			{
				if (i == 0 && Current_board[i][j] == 1)				//对我方，且第一排元素，父节点就是我方边界
				{
					union_find_father_first(&union_board[i][j])->father = union_find_father_first(&boundary[0]);
				}
				else if (i == 10 && Current_board[i][j] == 1)			//对我方，且第十一排元素，父节点就是我方边界
				{
					union_find_father_first(&union_board[i][j])->father = union_find_father_first(&boundary[2]);
				}
				if (Current_board[i][j] == 1)			//对我方，非第一排元素，周围己方落子点都归并一次，归并到该节点
				{
					if (j - 1 >= 0 && Current_board[i][j - 1] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i][j - 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (j - 1 >= 0 && i + 1 <= 10 && Current_board[i + 1][j - 1] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i + 1][j - 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i + 1 <= 10 && Current_board[i + 1][j] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i + 1][j]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (j + 1 <= 10 && Current_board[i][j + 1] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i][j + 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i - 1 >= 0 && j + 1 <= 10 && Current_board[i - 1][j + 1] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i - 1][j + 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i - 1 >= 0 && Current_board[i - 1][j] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i - 1][j]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
				}
			}
		}
		for (int j = 0; j < 11; j++)
		{
			for (int i = 0; i < 11; i++)
			{
				if (j == 0 && Current_board[i][j] == -1)				//对对方，且第一排元素，父节点就是对方边界
				{
					union_find_father_first(&union_board[i][j])->father = union_find_father_first(&boundary[1]);
				}
				if (j == 10 && Current_board[i][j] == -1)				//对对方，且第十一排元素，父节点就是对方边界
				{
					union_find_father_first(&union_board[i][j])->father = union_find_father_first(&boundary[3]);
				}
				if (Current_board[i][j] == -1)			//对对方，非第一列元素，周围己方落子点都归并一次，归并到该节点
				{
					if (j - 1 >= 0 && Current_board[i][j - 1] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i][j - 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (j - 1 >= 0 && i + 1 <= 10 && Current_board[i + 1][j - 1] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i + 1][j - 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i + 1 <= 10 && Current_board[i + 1][j] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i + 1][j]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (j + 1 <= 10 && Current_board[i][j + 1] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i][j + 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i - 1 >= 0 && j + 1 <= 10 && Current_board[i - 1][j + 1] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i - 1][j + 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i - 1 >= 0 && Current_board[i - 1][j] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i - 1][j]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
				}
			}
		}
	}
	else if (Current_board[1][2] == -1)			//对方先手
	{
		for (int i = 0; i < 11; i++)
		{
			for (int j = 0; j < 11; j++)
			{
				union_board[i][j].father = &union_board[i][j];
				union_board[i][j].x = i;
				union_board[i][j].y = j;
			}
		}
		for (int i = 0; i < 11; i++)
		{
			for (int j = 0; j < 11; j++)
			{
				if (i == 0 && Current_board[i][j] == -1)				//对对方，且第一排元素，父节点就是我方边界
				{
					union_find_father_first(&union_board[i][j])->father = union_find_father_first(&boundary[0]);
				}
				else if (i == 10 && Current_board[i][j] == -1)			//对对方，且第十一排元素，父节点就是我方边界
				{
					union_find_father_first(&union_board[i][j])->father = union_find_father_first(&boundary[2]);
				}
				if (Current_board[i][j] == -1)			//对对方，非第一排元素，周围己方落子点都归并一次，归并到j/y值最小的节点
				{
					if (j - 1 >= 0 && Current_board[i][j - 1] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i][j - 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (j - 1 >= 0 && i + 1 <= 10 && Current_board[i + 1][j - 1] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i + 1][j - 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i + 1 <= 10 && Current_board[i + 1][j] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i + 1][j]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (j + 1 <= 10 && Current_board[i][j + 1] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i][j + 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i - 1 >= 0 && j + 1 <= 10 && Current_board[i - 1][j + 1] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i - 1][j + 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i - 1 >= 0 && Current_board[i - 1][j] == -1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i - 1][j]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
				}
			}
		}
		for (int j = 0; j < 11; j++)
		{
			for (int i = 0; i < 11; i++)
			{
				if (j == 0 && Current_board[i][j] == 1)				//对我方，且第一排元素，父节点就是对方边界
				{
					union_find_father_first(&union_board[i][j])->father = union_find_father_first(&boundary[1]);
				}
				if (j == 10 && Current_board[i][j] == 1)				//对我方，且第十一排元素，父节点就是对方边界
				{
					union_find_father_first(&union_board[i][j])->father = union_find_father_first(&boundary[3]);
				}
				if (Current_board[i][j] == 1)			//对我方，非第一列元素，周围己方落子点都归并一次，归并到j/y值最小的节点
				{
					if (j - 1 >= 0 && Current_board[i][j - 1] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i][j - 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (j - 1 >= 0 && i + 1 <= 10 && Current_board[i + 1][j - 1] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i + 1][j - 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i + 1 <= 10 && Current_board[i + 1][j] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i + 1][j]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (j + 1 <= 10 && Current_board[i][j + 1] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i][j + 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i - 1 >= 0 && j + 1 <= 10 && Current_board[i - 1][j + 1] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i - 1][j + 1]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
					if (i - 1 >= 0 && Current_board[i - 1][j] == 1)
					{
						struct Union_node* p, * q;
						p = union_find_father_first(&union_board[i - 1][j]);
						q = union_find_father_first(&union_board[i][j]);
						p->father = q->father;
					}
				}
			}
		}
	}
	
	//当前并查集的构建
	
	for (int i = 0; i < 11; i++)
	{
		for (int j = 0; j < 11; j++)
		{
			struct Union_node* vir_father = union_find_father_first(&union_board[i][j]);
			if (vir_father->x != -1)
			{
				Current_union[i][j].father = &Current_union[vir_father->x][vir_father->y];
			}
			else
			{
				Current_union[i][j].father = &Current_boundary[vir_father->y];
			}
		}
	}
	for (int i = 0; i < 4; i++)
	{
		struct Union_node* vir_father = union_find_father_first(&boundary[i]);
		if (vir_father->x != -1)
		{
			Current_boundary[i].father = &Current_union[vir_father->x][vir_father->y];
		}
		else
		{
			Current_boundary[i].father = &Current_boundary[vir_father->y];
		}
	}
}

void union_board_reset()
{
	for (int i = 0; i < 11; i++)
	{
		for (int j = 0; j < 11; j++)
		{
			Current_union[i][j].father = &Current_union[i][j];
			Current_union[i][j].x = i;
			Current_union[i][j].y = j;
		}
	}
	for (int i = 0; i < 11; i++)
	{
		for (int j = 0; j < 11; j++)
		{
			struct Union_node* vir_father = union_find_father_first(&union_board[i][j]);
			if (vir_father->x != -1)
			{
				Current_union[i][j].father = &Current_union[vir_father->x][vir_father->y];
			}
			else
			{
				Current_union[i][j].father = &Current_boundary[vir_father->y];
			}
		}
	}
	for (int i = 0; i < 4; i++)
	{
		struct Union_node* vir_father = union_find_father_first(&boundary[i]);
		if (vir_father->x != -1)
		{
			Current_boundary[i].father = &Current_union[vir_father->x][vir_father->y];
		}
		else
		{
			Current_boundary[i].father = &Current_boundary[vir_father->y];
		}
	}
}

void union_find_update(int i, int j, int color)			//落点时并查集更新
{
	if (Current_board[1][2] == 1)			//我方先手
	{
		if (color == 1)			//我方落子
		{
			if (i == 0 && Current_board[i][j] == 1)				//对我方，且第一排元素，父节点就是我方边界
			{
				union_find_father(&Current_union[i][j])->father = union_find_father(&Current_boundary[0]);
			}
			else if (i == 10 && Current_board[i][j] == 1)			//对我方，且第十一排元素，父节点就是我方边界
			{
				union_find_father(&Current_union[i][j])->father = union_find_father(&Current_boundary[2]);
			}
			if (Current_board[i][j] == 1)			//对我方，非第一排元素，周围己方落子点都归并一次，归并到j/y值最小的节点
			{
				if (j - 1 >= 0 && Current_board[i][j - 1] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i][j - 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (j - 1 >= 0 && i + 1 <= 10 && Current_board[i + 1][j - 1] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i + 1][j - 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i + 1 <= 10 && Current_board[i + 1][j] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i + 1][j]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (j + 1 <= 10 && Current_board[i][j + 1] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i][j + 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i - 1 >= 0 && j + 1 <= 10 && Current_board[i - 1][j + 1] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i - 1][j + 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i - 1 >= 0 && Current_board[i - 1][j] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i - 1][j]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
			}
		}
		if (color == -1)			//对方落子
		{
			if (j == 0 && Current_board[i][j] == -1)				//对对方，且第一排元素，父节点就是对方边界
			{
				union_find_father(&Current_union[i][j])->father = union_find_father(&Current_boundary[1]);
			}
			if (j == 10 && Current_board[i][j] == -1)				//对对方，且第十一排元素，父节点就是对方边界
			{
				union_find_father(&Current_union[i][j])->father = union_find_father(&Current_boundary[3]);
			}
			if (Current_board[i][j] == -1)			//对对方，非第一列元素，周围己方落子点都归并一次，归并到j/y值最小的节点
			{
				if (j - 1 >= 0 && Current_board[i][j - 1] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i][j - 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (j - 1 >= 0 && i + 1 <= 10 && Current_board[i + 1][j - 1] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i + 1][j - 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i + 1 <= 10 && Current_board[i + 1][j] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i + 1][j]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (j + 1 <= 10 && Current_board[i][j + 1] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i][j + 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i - 1 >= 0 && j + 1 <= 10 && Current_board[i - 1][j + 1] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i - 1][j + 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i - 1 >= 0 && Current_board[i - 1][j] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i - 1][j]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
			}
		}
	}
	else if (Current_board[1][2] == -1)			//对方先手
	{
		if (color == -1)			//对方落子
		{
			if (i == 0 && Current_board[i][j] == -1)				//对对方，且第一排元素，父节点就是我方边界
			{
				union_find_father(&Current_union[i][j])->father = union_find_father(&Current_boundary[0]);
			}
			else if (i == 10 && Current_board[i][j] == -1)			//对对方，且第十一排元素，父节点就是我方边界
			{
				union_find_father(&Current_union[i][j])->father = union_find_father(&Current_boundary[2]);
			}
			if (Current_board[i][j] == -1)			//对方，非第一排元素，周围己方落子点都归并一次，归并到j/y值最小的节点
			{
				if (j - 1 >= 0 && Current_board[i][j - 1] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i][j - 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (j - 1 >= 0 && i + 1 <= 10 && Current_board[i + 1][j - 1] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i + 1][j - 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i + 1 <= 10 && Current_board[i + 1][j] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i + 1][j]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (j + 1 <= 10 && Current_board[i][j + 1] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i][j + 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i - 1 >= 0 && j + 1 <= 10 && Current_board[i - 1][j + 1] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i - 1][j + 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i - 1 >= 0 && Current_board[i - 1][j] == -1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i - 1][j]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
			}
		}
		if (color == 1)			//我方落子
		{
			if (j == 0 && Current_board[i][j] == 1)				//对我方，且第一排元素，父节点就是对方边界
			{
				union_find_father(&Current_union[i][j])->father = union_find_father(&Current_boundary[1]);
			}
			if (j == 10 && Current_board[i][j] == 1)				//对我方，且第十一排元素，父节点就是对方边界
			{
				union_find_father(&Current_union[i][j])->father = union_find_father(&Current_boundary[3]);
			}
			if (Current_board[i][j] == 1)			//对我方，非第一列元素，周围己方落子点都归并一次，归并到j/y值最小的节点
			{
				if (j - 1 >= 0 && Current_board[i][j - 1] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i][j - 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (j - 1 >= 0 && i + 1 <= 10 && Current_board[i + 1][j - 1] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i + 1][j - 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i + 1 <= 10 && Current_board[i + 1][j] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i + 1][j]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (j + 1 <= 10 && Current_board[i][j + 1] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i][j + 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i - 1 >= 0 && j + 1 <= 10 && Current_board[i - 1][j + 1] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i - 1][j + 1]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
				if (i - 1 >= 0 && Current_board[i - 1][j] == 1)
				{
					struct Union_node* p, * q;
					p = union_find_father(&Current_union[i - 1][j]);
					q = union_find_father(&Current_union[i][j]);
					p->father = q->father;
				}
			}
		}
	}
}

Union_node* union_find_father(Union_node* son)			//寻找并查集根结点
{
	if (son->father == son)				//根结点是自己，直接返回
		return son;
	else				//根结点不是自己，获取后更新
	{
		struct Union_node* final_father;
		final_father = union_find_father(son->father);
		son->father = final_father;
		return final_father;
	}
}

Union_node* union_find_father_first(Union_node* son)			//寻找并查集根结点
{
	if (son->father == son)				//根结点是自己，直接返回
		return son;
	else				//根结点不是自己，获取后更新
	{
		struct Union_node* final_father;
		final_father = union_find_father_first(son->father);
		son->father = final_father;
		return final_father;
	}
}

void fill_board()				//只填充桥，无用位置和被捕获位置，|||||同时获取脆弱的桥的信息，以攻击或防守，||||||同时获取被侵入的边界的信息，以防守
{
	int now_color = 1;
	for (int i = 0; i < 11; i++)
	{
		for (int j = 0; j < 11; j++)
		{
			if (visited[i][j] == 0)			//该点不是自己填的
			{
				//我方六个桥||||||else里是脆弱的桥
				
				
				if (i - 1 >= 0 && j - 1 >= 0 && Current_board[i][j] == 1 && Current_board[i - 1][j - 1] == 1 && Current_board[i - 1][j] == 0 && Current_board[i][j - 1] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i - 1][j] = 1;
						visited[i - 1][j] = 1;
						Current_board[i][j - 1] = -1;
						visited[i][j - 1] = 1;
					}
					else
					{
						Current_board[i - 1][j] = -1;
						visited[i - 1][j] = 1;
						Current_board[i][j - 1] = 1;
						visited[i][j - 1] = 1;
					}
				}
				if (i - 1 >= 0 && j + 2 <= 10 && Current_board[i][j] == 1 && Current_board[i + 1][j - 2] == 1 && Current_board[i][j - 1] == 0 && Current_board[i + 1][j - 1] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i][j - 1] = 1;
						visited[i][j - 1] = 1;
						Current_board[i + 1][j - 1] = -1;
						visited[i + 1][j - 1] = 1;
					}
					else
					{
						Current_board[i][j - 1] = -1;
						visited[i][j - 1] = 1;
						Current_board[i + 1][j - 1] = 1;
						visited[i + 1][j - 1] = 1;
					}
				}
				if (i - 1 >= 0 && j + 2 <= 10 && Current_board[i][j] == 1 && Current_board[i + 2][j - 1] == 1 && Current_board[i + 1][j] == 0 && Current_board[i + 1][j - 1] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i + 1][j] = 1;
						visited[i + 1][j] = 1;
						Current_board[i + 1][j - 1] = -1;
						visited[i + 1][j - 1] = 1;
					}
					else
					{
						Current_board[i + 1][j] = -1;
						visited[i + 1][j] = 1;
						Current_board[i + 1][j - 1] = 1;
						visited[i + 1][j - 1] = 1;
					}
				}
				if (i - 1 >= 0 && j + 2 <= 10 && Current_board[i][j] == 1 && Current_board[i - 1][j + 2] == 1 && Current_board[i][j + 1] == 0 && Current_board[i - 1][j + 1] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i][j + 1] = 1;
						visited[i][j + 1] = 1;
						Current_board[i - 1][j + 1] = -1;
						visited[i - 1][j + 1] = 1;
					}
					else
					{
						Current_board[i][j + 1] = -1;
						visited[i + 1][j - 1] = 1;
						Current_board[i - 1][j + 1] = 1;
						visited[i - 1][j + 1] = 1;
					}
				}
				if (i + 1 <= 10 && j + 1 <= 10 && Current_board[i][j] == 1 && Current_board[i + 1][j + 1] == 1 && Current_board[i][j + 1] == 0 && Current_board[i + 1][j] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i][j + 1] = 1;
						visited[i][j + 1] = 1;
						Current_board[i + 1][j] = -1;
						visited[i + 1][j] = 1;
					}
					else
					{
						Current_board[i][j + 1] = -1;
						visited[i][j + 1] = 1;
						Current_board[i + 1][j] = 1;
						visited[i + 1][j] = 1;
					}
				}
				if (i - 2 >= 0 && j + 1 <= 10 && j - 1 >= 0 && Current_board[i][j] == 1 && Current_board[i - 2][j + 1] == 1 && Current_board[i - 1][j + 1] == 0 && Current_board[i][j - 1] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i - 1][j + 1] = 1;
						visited[i - 1][j + 1] = 1;
						Current_board[i][j - 1] = -1;
						visited[i][j - 1] = 1;
					}
					else
					{
						Current_board[i - 1][j + 1] = -1;
						visited[i - 1][j + 1] = 1;
						Current_board[i][j - 1] = 1;
						visited[i][j - 1] = 1;
					}
				}
				
				
				//对方六个桥
				
				
				if (i - 1 >= 0 && j - 1 >= 0 && Current_board[i][j] == -1 && Current_board[i - 1][j - 1] == -1 && Current_board[i - 1][j] == 0 && Current_board[i][j - 1] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i - 1][j] = 1;
						visited[i - 1][j] = 1;
						Current_board[i][j - 1] = -1;
						visited[i][j - 1] = 1;
					}
					else
					{
						Current_board[i - 1][j] = -1;
						visited[i - 1][j] = 1;
						Current_board[i][j - 1] = 1;
						visited[i][j - 1] = 1;
					}
				}
				if (i - 1 >= 0 && j + 2 <= 10 && Current_board[i][j] == -1 && Current_board[i + 1][j - 2] == -1 && Current_board[i][j - 1] == 0 && Current_board[i + 1][j - 1] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i][j - 1] = 1;
						visited[i][j - 1] = 1;
						Current_board[i + 1][j - 1] = -1;
						visited[i + 1][j - 1] = 1;
					}
					else
					{
						Current_board[i][j - 1] = -1;
						visited[i][j - 1] = 1;
						Current_board[i + 1][j - 1] = 1;
						visited[i + 1][j - 1] = 1;
					}
				}
				if (i - 1 >= 0 && j + 2 <= 10 && Current_board[i][j] == -1 && Current_board[i + 2][j - 1] == -1 && Current_board[i + 1][j] == 0 && Current_board[i + 1][j - 1] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i + 1][j] = 1;
						visited[i + 1][j] = 1;
						Current_board[i + 1][j - 1] = -1;
						visited[i + 1][j - 1] = 1;
					}
					else
					{
						Current_board[i + 1][j] = -1;
						visited[i + 1][j] = 1;
						Current_board[i + 1][j - 1] = 1;
						visited[i + 1][j - 1] = 1;
					}
				}
				if (i - 1 >= 0 && j + 2 <= 10 && Current_board[i][j] == -1 && Current_board[i - 1][j + 2] == -1 && Current_board[i][j + 1] == 0 && Current_board[i - 1][j + 1] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i][j + 1] = 1;
						visited[i][j + 1] = 1;
						Current_board[i - 1][j + 1] = -1;
						visited[i - 1][j + 1] = 1;
					}
					else
					{
						Current_board[i][j + 1] = -1;
						visited[i + 1][j - 1] = 1;
						Current_board[i - 1][j + 1] = 1;
						visited[i - 1][j + 1] = 1;
					}
				}
				if (i + 1 <= 10 && j + 1 <= 10 && Current_board[i][j] == -1 && Current_board[i + 1][j + 1] == -1 && Current_board[i][j + 1] == 0 && Current_board[i + 1][j] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i][j + 1] = 1;
						visited[i][j + 1] = 1;
						Current_board[i + 1][j] = -1;
						visited[i + 1][j] = 1;
					}
					else
					{
						Current_board[i][j + 1] = -1;
						visited[i][j + 1] = 1;
						Current_board[i + 1][j] = 1;
						visited[i + 1][j] = 1;
					}
				}
				if (i - 2 >= 0 && j + 1 <= 10 && j - 1 >= 0 && Current_board[i][j] == -1 && Current_board[i - 2][j + 1] == -1 && Current_board[i - 1][j + 1] == 0 && Current_board[i][j - 1] == 0)
				{
					int random_number = (rand() % 2) + 0;
					if (random_number == 0)
					{
						Current_board[i - 1][j + 1] = 1;
						visited[i - 1][j + 1] = 1;
						Current_board[i][j - 1] = -1;
						visited[i][j - 1] = 1;
					}
					else
					{
						Current_board[i - 1][j + 1] = -1;
						visited[i - 1][j + 1] = 1;
						Current_board[i][j - 1] = 1;
						visited[i][j - 1] = 1;
					}
				}
				
				
				//我方无用位置1
				
				
				if (i - 2 >= 0 && j + 2 <= 10 && Current_board[i][j] == 1 && Current_board[i][j + 1] == 1 && Current_board[i - 1][j + 2] == 1 && Current_board[i - 2][j + 2] == 1 && Current_board[i - 1][j + 1] == 0)
				{
					useless_nodes_x.push(i - 1);
					useless_node_y.push(j + 1);
				}
				if (i - 2 >= 0 && j + 1 <= 10 && Current_board[i][j] == 1 && Current_board[i - 1][j + 1] == 1 && Current_board[i - 2][j + 1] == 1 && Current_board[i - 2][j] == 1 && Current_board[i - 1][j] == 0)
				{
					useless_nodes_x.push(i - 1);
					useless_node_y.push(j);
				}
				if (i - 1 >= 0 && j - 2 >= 0 && Current_board[i][j] == 1 && Current_board[i - 1][j] == 1 && Current_board[i - 1][j - 1] == 1 && Current_board[i][j - 2] == 1 && Current_board[i][j - 1] == 0)
				{
					useless_nodes_x.push(i);
					useless_node_y.push(j - 1);
				}
				if (i + 2 <= 10 && j - 2 >= 0 && Current_board[i][j] == 1 && Current_board[i][j - 1] == 1 && Current_board[i + 1][j - 2] == 1 && Current_board[i + 2][j - 2] == 1 && Current_board[i + 1][j - 1] == 0)
				{
					useless_nodes_x.push(i + 1);
					useless_node_y.push(j - 1);
				}
				if (i + 2 <= 10 && j - 1 >= 0 && Current_board[i][j] == 1 && Current_board[i + 1][j - 1] == 1 && Current_board[i + 2][j - 1] == 1 && Current_board[i + 2][j] == 1 && Current_board[i + 1][j] == 0)
				{
					useless_nodes_x.push(i + 1);
					useless_node_y.push(j);
				}
				if (i + 1 <= 10 && j + 2 <= 10 && Current_board[i][j] == 1 && Current_board[i + 1][j] == 1 && Current_board[i + 1][j + 1] == 1 && Current_board[i][j + 2] == 1 && Current_board[i][j + 1] == 0)
				{
					useless_nodes_x.push(i);
					useless_node_y.push(j + 1);
				}
				
				
				//我方无用位置2
				if (i - 2 >= 0 && j + 2 <= 10 && Current_board[i][j] == 1 && Current_board[i - 1][j + 1] == 0 && Current_board[i - 2][j + 1] == -1 && Current_board[i - 2][j + 2] == -1 && Current_board[i - 1][j + 2] == -1)
				{
					useless_nodes_x.push(i - 1);
					useless_node_y.push(j + 1);
				}
				if (i - 2 >= 0 && j + 1 <= 10 && j - 1 >= 0 && Current_board[i][j] == 1 && Current_board[i - 1][j] == 0 && Current_board[i - 1][j - 1] == -1 && Current_board[i - 2][j] == -1 && Current_board[i - 2][j + 1] == -1)
				{
					useless_nodes_x.push(i - 1);
					useless_node_y.push(j);
				}
				if (i - 1 >= 0 && j - 2 >= 0 && i + 1 <= 10 && Current_board[i][j] == 1 && Current_board[i][j - 1] == 0 && Current_board[i + 1][j - 2] == -1 && Current_board[i][j - 2] == -1 && Current_board[i - 1][j - 1] == -1)
				{
					useless_nodes_x.push(i);
					useless_node_y.push(j - 1);
				}
				if (j - 2 >= 0 && i + 2 <= 10 && Current_board[i][j] == 1 && Current_board[i + 1][j - 1] == 0 && Current_board[i + 2][j - 1] == -1 && Current_board[i + 2][j - 2] == -1 && Current_board[i + 1][j - 2] == -1)
				{
					useless_nodes_x.push(i + 1);
					useless_node_y.push(j - 1);
				}
				if (i + 2 <= 10 && j + 1 <= 10 && j - 1 >= 0 && Current_board[i][j] == 1 && Current_board[i + 1][j] == 0 && Current_board[i + 1][j + 1] == -1 && Current_board[i + 2][j] == -1 && Current_board[i + 2][j - 1] == -1)
				{
					useless_nodes_x.push(i + 1);
					useless_node_y.push(j);
				}
				if (i - 1 >= 0 && j + 2 <= 10 && i + 1 <= 10 && Current_board[i][j] == 1 && Current_board[i][j + 1] == 0 && Current_board[i - 1][j + 2] == -1 && Current_board[i][j + 2] == -1 && Current_board[i + 1][j + 1] == -1)
				{
					useless_nodes_x.push(i);
					useless_node_y.push(j + 1);
				}
				
				
				//公共无用位置
				if (i - 2 >= 0 && j + 2 <= 10 && Current_board[i][j] == 1 && Current_board[i][j + 1] == 1 && Current_board[i - 1][j + 1] == 0 && Current_board[i - 2][j + 1] == -1 && Current_board[i - 2][j + 2] == -1)
				{
					useless_nodes_x.push(i - 1);
					useless_node_y.push(j + 1);
				}
				if (i - 2 >= 0 && j + 1 <= 10 && j - 1 >= 0 && Current_board[i][j] == 1 && Current_board[i - 1][j + 1] == 1 && Current_board[i - 1][j] == 0 && Current_board[i - 1][j - 1] == -1 && Current_board[i - 2][j] == -1)
				{
					useless_nodes_x.push(i - 1);
					useless_node_y.push(j);
				}
				if (j - 2 >= 0 && i + 1 <= 10 && i - 1 >= 0 && Current_board[i][j] == 1 && Current_board[i - 1][j] == 1 && Current_board[i][j - 1] == 0 && Current_board[i + 1][j - 2] == -1 && Current_board[i][j - 2] == -1)
				{
					useless_nodes_x.push(i);
					useless_node_y.push(j - 1);
				}
				if (j - 2 >= 0 && i + 2 <= 10 && Current_board[i][j] == 1 && Current_board[i][j - 1] == 1 && Current_board[i + 1][j - 1] == 0 && Current_board[i + 2][j - 1] == -1 && Current_board[i + 2][j - 2] == -1)
				{
					useless_nodes_x.push(i + 1);
					useless_node_y.push(j - 1);
				}
				if (i + 2 <= 10 && j + 1 <= 10 && j - 1 >= 0 && Current_board[i][j] == 1 && Current_board[i + 1][j - 1] == 1 && Current_board[i + 1][j] == 0 && Current_board[i + 1][j + 1] == -1 && Current_board[i + 2][j] == -1)
				{
					useless_nodes_x.push(i + 1);
					useless_node_y.push(j);
				}
				if (j + 2 <= 10 && i + 1 <= 10 && i - 1 >= 0 && Current_board[i][j] == 1 && Current_board[i + 1][j] == 1 && Current_board[i][j + 1] == 0 && Current_board[i - 1][j + 2] == -1 && Current_board[i][j + 2] == -1)
				{
					useless_nodes_x.push(i);
					useless_node_y.push(j + 1);
				}
				
				
				//对方无用位置1
				if (i - 2 >= 0 && j + 2 <= 10 && Current_board[i][j] == -1 && Current_board[i][j + 1] == -1 && Current_board[i - 1][j + 2] == -1 && Current_board[i - 2][j + 2] == -1 && Current_board[i - 1][j + 1] == 0)
				{
					useless_nodes_x.push(i - 1);
					useless_node_y.push(j + 1);
				}
				if (i - 2 >= 0 && j + 1 <= 10 && Current_board[i][j] == -1 && Current_board[i - 1][j + 1] == -1 && Current_board[i - 2][j + 1] == -1 && Current_board[i - 2][j] == -1 && Current_board[i - 1][j] == 0)
				{
					useless_nodes_x.push(i - 1);
					useless_node_y.push(j);
				}
				if (i - 1 >= 0 && j - 2 >= 0 && Current_board[i][j] == -1 && Current_board[i - 1][j] == -1 && Current_board[i - 1][j - 1] == -1 && Current_board[i][j - 2] == -1 && Current_board[i][j - 1] == 0)
				{
					useless_nodes_x.push(i);
					useless_node_y.push(j - 1);
				}
				if (i + 2 <= 10 && j - 2 >= 0 && Current_board[i][j] == -1 && Current_board[i][j - 1] == -1 && Current_board[i + 1][j - 2] == -1 && Current_board[i + 2][j - 2] == -1 && Current_board[i + 1][j - 1] == 0)
				{
					useless_nodes_x.push(i + 1);
					useless_node_y.push(j - 1);
				}
				if (i + 2 <= 10 && j - 1 >= 0 && Current_board[i][j] == -1 && Current_board[i + 1][j - 1] == -1 && Current_board[i + 2][j - 1] == -1 && Current_board[i + 2][j] == -1 && Current_board[i + 1][j] == 0)
				{
					useless_nodes_x.push(i + 1);
					useless_node_y.push(j);
				}
				if (i + 1 <= 10 && j + 2 <= 10 && Current_board[i][j] == -1 && Current_board[i + 1][j] == -1 && Current_board[i + 1][j + 1] == -1 && Current_board[i][j + 2] == -1 && Current_board[i][j + 1] == 0)
				{
					useless_nodes_x.push(i);
					useless_node_y.push(j + 1);
				}
				
				
				//对方无用位置2
				if (i - 2 >= 0 && j + 2 <= 10 && Current_board[i][j] == -1 && Current_board[i - 1][j + 1] == 0 && Current_board[i - 2][j + 1] == 1 && Current_board[i - 2][j + 2] == 1 && Current_board[i - 1][j + 2] == 1)
				{
					useless_nodes_x.push(i - 1);
					useless_node_y.push(j + 1);
				}
				if (i - 2 >= 0 && j + 1 <= 10 && j - 1 >= 0 && Current_board[i][j] == -1 && Current_board[i - 1][j] == 0 && Current_board[i - 1][j - 1] == 1 && Current_board[i - 2][j] == 1 && Current_board[i - 2][j + 1] == 1)
				{
					useless_nodes_x.push(i - 1);
					useless_node_y.push(j);
				}
				if (i - 1 >= 0 && j - 2 >= 0 && i + 1 <= 10 && Current_board[i][j] == -1 && Current_board[i][j - 1] == 0 && Current_board[i + 1][j - 2] == 1 && Current_board[i][j - 2] == 1 && Current_board[i - 1][j - 1] == 1)
				{
					useless_nodes_x.push(i);
					useless_node_y.push(j - 1);
				}
				if (j - 2 >= 0 && i + 2 <= 10 && Current_board[i][j] == -1 && Current_board[i + 1][j - 1] == 0 && Current_board[i + 2][j - 1] == 1 && Current_board[i + 2][j - 2] == 1 && Current_board[i + 1][j - 2] == 1)
				{
					useless_nodes_x.push(i + 1);
					useless_node_y.push(j - 1);
				}
				if (i + 2 <= 10 && j + 1 <= 10 && j - 1 >= 0 && Current_board[i][j] == -1 && Current_board[i + 1][j] == 0 && Current_board[i + 1][j + 1] == 1 && Current_board[i + 2][j] == 1 && Current_board[i + 2][j - 1] == 1)
				{
					useless_nodes_x.push(i + 1);
					useless_node_y.push(j);
				}
				if (i - 1 >= 0 && j + 2 <= 10 && i + 1 <= 10 && Current_board[i][j] == -1 && Current_board[i][j + 1] == 0 && Current_board[i - 1][j + 2] == 1 && Current_board[i][j + 2] == 1 && Current_board[i + 1][j + 1] == 1)
				{
					useless_nodes_x.push(i);
					useless_node_y.push(j + 1);
				}
				while (useless_nodes_x.size() >= 2)				//随机落子
				{
					int x = useless_nodes_x.top();
					int y = useless_node_y.top();
					Current_board[x][y] = 1;
					visited[x][y] = 1;
					useless_nodes_x.pop();
					useless_node_y.pop();
					
					x = useless_nodes_x.top();
					y = useless_node_y.top();
					Current_board[x][y] = -1;
					visited[x][y] = 1;
					useless_nodes_x.pop();
					useless_node_y.pop();
				}
				if (useless_nodes_x.size())
				{
					int x = useless_nodes_x.top();
					int y = useless_node_y.top();
					Current_board[x][y] = now_color;
					now_color = -now_color;
					visited[x][y] = 1;
					useless_nodes_x.pop();
					useless_node_y.pop();
				}
				visited[i][j] = 1;
			}
		}
	}
}

void visited_reset()
{
	for (int i = 0; i < 11; i++)
	{
		for (int j = 0; j < 11; j++)
		{
			visited[i][j] = 0;
		}
	}
}


int protect(int x, int y)
{
	//判断桥是否被破坏
	if (x - 1 >= 0 && y + 1 <= 10 && iniboard[x][y] == -1 && iniboard[x - 1][y] == 1 && iniboard[x][y + 1] == 1 && iniboard[x - 1][y + 1] == 0)
	{
		printf("%d %d", x - 1, y + 1);
		return 0;
	}
	if (y - 1 >= 0 && x - 1 >= 0 && y + 1 <= 10 && iniboard[x][y] == -1 && iniboard[x][y - 1] == 1 && iniboard[x - 1][y + 1] == 1 && iniboard[x - 1][y] == 0)
	{
		printf("%d %d", x - 1, y);
		return 0;
	}
	if (x + 1 <= 10 && y - 1 >= 0 && x - 1 >= 0 && iniboard[x][y] == -1 && iniboard[x + 1][y - 1] == 1 && iniboard[x - 1][y] == 1 && iniboard[x][y - 1] == 0)
	{
		printf("%d %d", x, y - 1);
		return 0;
	}
	if (y - 1 >= 0 && x + 1 <= 10 && iniboard[x][y] == -1 && iniboard[x][y - 1] == 1 && iniboard[x + 1][y] == 1 && iniboard[x + 1][y - 1] == 0)
	{
		printf("%d %d", x + 1, y - 1);
		return 0;
	}
	if (x + 1 <= 10 && y - 1 >= 0 && y + 1 <= 10 && iniboard[x][y] == -1 && iniboard[x + 1][y - 1] == 1 && iniboard[x][y + 1] == 1 && iniboard[x + 1][y] == 0)
	{
		printf("%d %d", x + 1, y);
		return 0;
	}
	if (x + 1 <= 10 && x - 1 >= 0 && y + 1 <= 10 && iniboard[x][y] == -1 && iniboard[x + 1][y] == 1 && iniboard[x - 1][y + 1] == 1 && iniboard[x][y + 1] == 0)
	{
		printf("%d %d", x, y + 1);
		return 0;
	}
	
	//判断边界是否被破坏
	if (iniboard[1][2] == 1)			//我方先手
	{
		if (x == 0)						//侵入高度为2的边界  2种      侵入高度为3的边界  8种
		{
			if (x + 1 <= 10 && y - 1 >= 0 && iniboard[x + 1][y - 1] == 1 && iniboard[x][y - 1] == 0)
			{
				printf("%d %d", x, y - 1);
				return 0;
			}
			if (x + 1 <= 10 && y + 1 <= 10 && iniboard[x + 1][y] == 1 && iniboard[x][y + 1] == 0)
			{
				printf("%d %d", x, y + 1);
				return 0;
			}
			if (x + 2 <= 10 && y - 3 >= 0 && iniboard[x + 2][y - 2] == 1 && iniboard[x + 1][y - 2] == 0 && iniboard[x + 2][y - 3] == 0 && iniboard[x][y - 2] == 0 && iniboard[x][y - 3] == 0 && iniboard[x + 1][y - 3] == 0)
			{
				printf("%d %d", x + 1, y - 3);
				return 0;
			}
			if (x + 2 <= 10 && y - 3 >= 0 && iniboard[x + 2][y - 2] == 0 && iniboard[x + 1][y - 2] == 0 && iniboard[x + 2][y - 3] == 1 && iniboard[x][y - 2] == 0 && iniboard[x][y - 3] == 0 && iniboard[x + 1][y - 3] == 0)
			{
				printf("%d %d", x + 1, y - 3);
				return 0;
			}
			if (x + 2 <= 10 && y - 2 >= 0 && iniboard[x + 2][y - 1] == 1 && iniboard[x + 1][y - 1] == 0 && iniboard[x + 2][y - 2] == 0 && iniboard[x][y - 1] == 0 && iniboard[x][y - 2] == 0 && iniboard[x + 1][y - 2] == 0)
			{
				printf("%d %d", x + 1, y - 2);
				return 0;
			}
			if (x + 2 <= 10 && y - 2 >= 0 && x - 1 >= 0 && iniboard[x + 2][y - 1] == 0 && iniboard[x + 1][y - 1] == 0 && iniboard[x + 2][y - 2] == 1 && iniboard[x][y - 1] == 0 && iniboard[x][y - 2] == 0 && iniboard[x - 1][y - 2] == 0)
			{
				printf("%d %d", x + 1, y - 2);
				return 0;
			}
			if (x + 2 <= 10 && y - 1 >= 0 && y + 2 <= 0 && iniboard[x + 2][y] == 1 && iniboard[x + 1][y] == 0 && iniboard[x + 2][y - 1] == 0 && iniboard[x][y + 1] == 0 && iniboard[x][y + 2] == 0 && iniboard[x + 1][y + 1] == 0)
			{
				printf("%d %d", x + 1, y + 1);
				return 0;
			}
			if (x + 2 <= 10 && y - 1 >= 0 && y + 2 <= 10 && iniboard[x + 2][y] == 0 && iniboard[x + 1][y] == 0 && iniboard[x + 2][y - 1] == 1 && iniboard[x][y + 1] == 0 && iniboard[x][y + 2] == 0 && iniboard[x + 1][y + 1] == 0)
			{
				printf("%d %d", x + 1, y + 1);
				return 0;
			}
			if (x + 2 <= 10 && y + 3 <= 10 && iniboard[x + 2][y + 1] == 1 && iniboard[x + 1][y + 1] == 0 && iniboard[x + 2][y] == 0 && iniboard[x][y + 2] == 0 && iniboard[x][y + 3] == 0 && iniboard[x + 1][y + 2] == 0)
			{
				printf("%d %d", x + 1, y + 2);
				return 0;
			}
			if (x + 2 <= 10 && y + 3 <= 10 && iniboard[x + 2][y + 1] == 0 && iniboard[x + 1][y + 1] == 0 && iniboard[x + 2][y] == 1 && iniboard[x][y + 2] == 0 && iniboard[x][y + 3] == 0 && iniboard[x + 1][y + 2] == 0)
			{
				printf("%d %d", x + 1, y + 2);
				return 0;
			}
			
		}
		if (x == 10)						//侵入高度为2的边界  2种		侵入高度为3的边界  8 种
		{
			if (x - 1 >= 0 && y - 1 >= 0 && iniboard[x - 1][y] == 1 && iniboard[x][y - 1] == 0)
			{
				printf("%d %d", x, y - 1);
				return 0;
			}
			if (x - 1 >= 0 && y + 1 <= 10 && iniboard[x - 1][y + 1] == 1 && iniboard[x][y + 1] == 0)
			{
				printf("%d %d", x, y + 1);
				return 0;
			}
			if (x - 2 >= 0 && y + 3 <= 10 && iniboard[x - 2][y + 2] == 1 && iniboard[x - 1][y + 2] == 0 && iniboard[x - 2][y + 3] == 0 && iniboard[x][y + 2] == 0 && iniboard[x][y + 3] == 0 && iniboard[x - 1][y + 3] == 0)
			{
				printf("%d %d", x - 1, y + 3);
				return 0;
			}
			if (x - 2 >= 0 && y + 3 <= 10 && iniboard[x - 2][y + 2] == 0 && iniboard[x - 1][y + 2] == 0 && iniboard[x - 2][y + 3] == 1 && iniboard[x][y + 2] == 0 && iniboard[x][y + 3] == 0 && iniboard[x - 1][y + 3] == 0)
			{
				printf("%d %d", x - 1, y + 3);
				return 0;
			}
			if (x - 2 >= 0 && y + 2 <= 10 && iniboard[x - 2][y + 1] == 1 && iniboard[x - 1][y + 1] == 0 && iniboard[x - 2][y + 2] == 0 && iniboard[x][y + 1] == 0 && iniboard[x][y + 2] == 0 && iniboard[x - 1][y + 2] == 0)
			{
				printf("%d %d", x - 1, y + 2);
				return 0;
			}
			if (x - 2 >= 0 && y + 2 <= 10 && iniboard[x - 2][y + 1] == 0 && iniboard[x - 1][y + 1] == 0 && iniboard[x - 2][y + 2] == 1 && iniboard[x][y + 1] == 0 && iniboard[x][y + 2] == 0 && iniboard[x - 1][y + 2] == 0)
			{
				printf("%d %d", x - 1, y + 2);
				return 0;
			}
			if (x - 2 >= 0 && y + 1 <= 10 && y - 2 >= 0 && iniboard[x - 2][y] == 1 && iniboard[x - 1][y] == 0 && iniboard[x - 2][y + 1] == 0 && iniboard[x][y - 1] == 0 && iniboard[x][y - 2] == 0 && iniboard[x - 1][y - 1] == 0)
			{
				printf("%d %d", x - 1, y - 1);
				return 0;
			}
			if (x - 2 >= 0 && y + 1 <= 10 && y - 2 >= 0 && iniboard[x - 2][y] == 0 && iniboard[x - 1][y] == 0 && iniboard[x - 2][y + 1] == 1 && iniboard[x][y - 1] == 0 && iniboard[x][y - 2] == 0 && iniboard[x - 1][y - 1] == 0)
			{
				printf("%d %d", x - 1, y - 1);
				return 0;
			}
			if (x - 2 >= 0 && y - 3 >= 0 && iniboard[x - 2][y - 1] == 1 && iniboard[x - 1][y - 1] == 0 && iniboard[x - 2][y] == 0 && iniboard[x][y - 2] == 0 && iniboard[x][y - 3] == 0 && iniboard[x - 1][y - 2] == 0)
			{
				printf("%d %d", x - 1, y - 2);
				return 0;
			}
			if (x - 2 >= 0 && y - 3 >= 0 && iniboard[x - 2][y - 1] == 0 && iniboard[x - 1][y - 1] == 0 && iniboard[x - 2][y] == 1 && iniboard[x][y - 2] == 0 && iniboard[x][y - 3] == 0 && iniboard[x - 1][y - 2] == 0)
			{
				printf("%d %d", x - 1, y - 2);
				return 0;
			}
		}
		if (x == 1)					//高度为3的边界  6种
		{
			if (x + 1 <= 10 && x - 1 >= 0 && y + 3 <= 10 && iniboard[x + 1][y] == 1 && iniboard[x + 1][y + 1] == 0 && iniboard[x][y + 1] == 0 && iniboard[x - 1][y + 2] == 0 && iniboard[x - 1][y + 3] == 0 && iniboard[x][y + 2] == 0)
			{
				printf("%d %d", x, y + 2);
				return 0;
			}
			if (x + 1 <= 10 && x - 1 >= 0 && y + 3 <= 10 && iniboard[x + 1][y] == 0 && iniboard[x + 1][y + 1] == 1 && iniboard[x][y + 1] == 0 && iniboard[x - 1][y + 2] == 0 && iniboard[x - 1][y + 3] == 0 && iniboard[x][y + 2] == 0)
			{
				printf("%d %d", x, y + 2);
				return 0;
			}
			if (x + 1 <= 10 && x - 1 >= 0 && y - 1 >= 0 && y + 2 <= 10 && iniboard[x + 1][y - 1] == 1 && iniboard[x + 1][y] == 0 && iniboard[x - 1][y - 1] == 0 && iniboard[x - 1][y] == 0 && iniboard[x][y - 1] == 0)
			{
				printf("%d %d", x, y - 1);
				return 0;
			}
			if (x + 1 <= 10 && x - 1 >= 0 && y - 1 >= 0 && y + 2 <= 10 && iniboard[x + 1][y - 1] == 0 && iniboard[x + 1][y] == 1 && iniboard[x - 1][y + 1] == 0 && iniboard[x - 1][y + 2] == 0 && iniboard[x][y + 1] == 0)
			{
				printf("%d %d", x, y + 1);
				return 0;
			}
			if (x + 1 <= 10 && x - 1 >= 0 && y + 1 <= 10 && y - 2 >= 0 && iniboard[x + 1][y - 2] == 1 && iniboard[x + 1][y - 1] == 0 && iniboard[x][y - 1] == 0 && iniboard[x - 1][y - 2] == 0 && iniboard[x - 1][y - 1] == 0 && iniboard[x][y - 2] == 0)
			{
				printf("%d %d", x, y - 2);
				return 0;
			}
			if (x + 1 <= 10 && x - 1 >= 0 && y + 1 <= 10 && y - 2 >= 0 && iniboard[x + 1][y - 2] == 0 && iniboard[x + 1][y - 1] == 1 && iniboard[x][y - 1] == 0 && iniboard[x - 1][y - 2] == 0 && iniboard[x - 1][y - 1] == 0 && iniboard[x][y - 2] == 0)
			{
				printf("%d %d", x, y - 2);
				return 0;
			}
		}
		if (x == 9)
		{
			if (x - 1 >= 0 && x + 1 <= 10 && y - 3 >= 0 && iniboard[x - 1][y] == 1 && iniboard[x - 1][y - 1] == 0 && iniboard[x][y - 1] == 0 && iniboard[x + 1][y - 2] == 0 && iniboard[x + 1][y - 3] == 0 && iniboard[x][y - 2] == 0)
			{
				printf("%d %d", x, y - 2);
				return 0;
			}
			if (x - 1 >= 0 && x + 1 <= 10 && y - 3 >= 0 && iniboard[x - 1][y] == 0 && iniboard[x - 1][y - 1] == 1 && iniboard[x][y - 1] == 0 && iniboard[x + 1][y - 2] == 0 && iniboard[x + 1][y - 3] == 0 && iniboard[x][y - 2] == 0)
			{
				printf("%d %d", x, y - 2);
				return 0;
			}
			if (x - 1 >= 0 && x + 1 <= 10 && y + 1 <= 10 && y - 2 >= 10 && iniboard[x - 1][y + 1] == 1 && iniboard[x - 1][y] == 0 && iniboard[x + 1][y + 1] == 0 && iniboard[x + 1][y] == 0 && iniboard[x][y + 1] == 0)
			{
				printf("%d %d", x, y + 1);
				return 0;
			}
			if (x - 1 >= 0 && x + 1 <= 10 && y + 1 <= 10 && y - 2 >= 10 && iniboard[x - 1][y + 1] == 0 && iniboard[x - 1][y] == 1 && iniboard[x + 1][y - 1] == 0 && iniboard[x + 1][y - 2] == 0 && iniboard[x][y - 1] == 0)
			{
				printf("%d %d", x, y - 1);
				return 0;
			}
			if (x - 1 >= 0 && x + 1 <= 10 && y - 1 >= 0 && y + 2 <= 10 && iniboard[x - 1][y + 2] == 1 && iniboard[x - 1][y + 1] == 0 && iniboard[x][y + 1] == 0 && iniboard[x + 1][y + 2] == 0 && iniboard[x + 1][y + 1] == 0 && iniboard[x][y + 2] == 0)
			{
				printf("%d %d", x, y + 2);
				return 0;
			}
			if (x - 1 >= 0 && x + 1 <= 10 && y - 1 >= 0 && y + 2 <= 10 && iniboard[x - 1][y + 2] == 0 && iniboard[x - 1][y + 1] == 1 && iniboard[x][y + 1] == 0 && iniboard[x + 1][y + 2] == 0 && iniboard[x + 1][y + 1] == 0 && iniboard[x][y + 2] == 0)
			{
				printf("%d %d", x, y + 2);
				return 0;
			}
		}
	}
	else if (iniboard[1][2] == -1)			//我方后手
	{
		if (y == 0)						//侵入高度为2的边界  2种      侵入高度为3的边界  8种
		{
			if (y + 1 <= 10 && x - 1 >= 0 && iniboard[x - 1][y + 1] == 1 && iniboard[x - 1][y] == 0)
			{
				printf("%d %d", x - 1, y);
				return 0;
			}
			if (y + 1 <= 10 && x + 1 <= 10 && iniboard[x][y + 1] == 1 && iniboard[x + 1][y] == 0)
			{
				printf("%d %d", x + 1, y);
				return 0;
			}
			if (y + 2 <= 10 && x - 3 >= 0 && iniboard[x - 2][y + 2] == 1 && iniboard[x - 2][y + 1] == 0 && iniboard[x - 3][y + 2] == 0 && iniboard[x - 2][y] == 0 && iniboard[x - 3][y] == 0 && iniboard[x - 3][y + 1] == 0)
			{
				printf("%d %d", x - 3, y + 1);
				return 0;
			}
			if (y + 2 <= 10 && x - 3 >= 0 && iniboard[x - 2][y + 2] == 0 && iniboard[x - 2][y + 1] == 0 && iniboard[x - 3][y + 2] == 1 && iniboard[x - 2][y] == 0 && iniboard[x - 3][y] == 0 && iniboard[x - 3][y + 1] == 0)
			{
				printf("%d %d", x - 3, y + 1);
				return 0;
			}
			if (y + 2 <= 10 && x - 2 >= 0 && iniboard[x - 1][y + 2] == 1 && iniboard[x - 1][y + 1] == 0 && iniboard[x - 2][y + 2] == 0 && iniboard[x - 1][y] == 0 && iniboard[x - 2][y] == 0 && iniboard[x - 2][y + 1] == 0)
			{
				printf("%d %d", x - 2, y + 1);
				return 0;
			}
			if (y + 2 <= 10 && x - 2 >= 0 && y - 1 >= 0 && iniboard[x - 1][y + 2] == 0 && iniboard[x - 1][y + 1] == 0 && iniboard[x - 2][y + 2] == 1 && iniboard[x - 1][y] == 0 && iniboard[x - 2][y] == 0 && iniboard[x - 2][y - 1] == 0)
			{
				printf("%d %d", x - 2, y + 1);
				return 0;
			}
			if (y + 2 <= 10 && x - 1 >= 0 && x + 2 <= 10 && iniboard[x][y + 2] == 1 && iniboard[x][y + 1] == 0 && iniboard[x - 1][y + 2] == 0 && iniboard[x + 1][y] == 0 && iniboard[x + 2][y] == 0 && iniboard[x + 1][y + 1] == 0)
			{
				printf("%d %d", x + 1, y + 1);
				return 0;
			}
			if (y + 2 <= 10 && x - 1 >= 0 && x + 2 <= 10 && iniboard[x][y + 2] == 0 && iniboard[x][y + 1] == 0 && iniboard[x - 1][y + 2] == 1 && iniboard[x + 1][y] == 0 && iniboard[x + 2][y] == 0 && iniboard[x + 1][y + 1] == 0)
			{
				printf("%d %d", x + 1, y + 1);
				return 0;
			}
			if (y + 2 <= 0 && x + 3 <= 10 && iniboard[x + 1][y + 2] == 1 && iniboard[x + 1][y + 1] == 0 && iniboard[x][y + 2] == 0 && iniboard[x + 2][y] == 0 && iniboard[x + 3][y] == 0 && iniboard[x + 2][y + 1] == 0)
			{
				printf("%d %d", x + 2, y + 1);
				return 0;
			}
			if (y + 2 <= 0 && x + 3 <= 10 && iniboard[x + 1][y + 2] == 0 && iniboard[x + 1][y + 1] == 0 && iniboard[x][y + 2] == 1 && iniboard[x + 2][y] == 0 && iniboard[x + 3][y] == 0 && iniboard[x + 2][y + 1] == 0)
			{
				printf("%d %d", x + 2, y + 1);
				return 0;
			}
			
		}
		if (y == 10)						//侵入高度为2的边界  2种		侵入高度为3的边界  8 种
		{
			if (y - 1 >= 10 && x - 1 >= 0 && iniboard[x][y - 1] == 1 && iniboard[x - 1][y] == 0)
			{
				printf("%d %d", x - 1, y);
				return 0;
			}
			if (y - 1 >= 10 && x + 1 <= 10 && iniboard[x + 1][y - 1] == 1 && iniboard[x + 1][y] == 0)
			{
				printf("%d %d", x + 1, y);
				return 0;
			}
			if (y - 2 >= 0 && x + 3 <= 10 && iniboard[x + 2][y - 2] == 1 && iniboard[x + 2][y - 1] == 0 && iniboard[x + 3][y - 2] == 0 && iniboard[x + 2][y] == 0 && iniboard[x + 3][y] == 0 && iniboard[x + 3][y - 1] == 0)
			{
				printf("%d %d", x + 3, y - 1);
				return 0;
			}
			if (y - 2 >= 0 && x + 3 <= 10 && iniboard[x + 2][y - 2] == 0 && iniboard[x + 2][y - 1] == 0 && iniboard[x + 3][y - 2] == 1 && iniboard[x + 2][y] == 0 && iniboard[x + 3][y] == 0 && iniboard[x + 3][y - 1] == 0)
			{
				printf("%d %d", x + 3, y - 1);
				return 0;
			}
			if (y - 2 >= 0 && x + 2 <= 10 && iniboard[x + 1][y - 2] == 1 && iniboard[x + 1][y - 1] == 0 && iniboard[x + 2][y - 2] == 0 && iniboard[x + 1][y] == 0 && iniboard[x + 2][y] == 0 && iniboard[x + 2][y - 1] == 0)
			{
				printf("%d %d", x + 2, y - 1);
				return 0;
			}
			if (y - 2 >= 0 && x + 2 <= 10 && iniboard[x + 1][y - 2] == 0 && iniboard[x + 1][y - 1] == 0 && iniboard[x + 2][y - 2] == 1 && iniboard[x + 1][y] == 0 && iniboard[x + 2][y] == 0 && iniboard[x + 2][y - 1] == 0)
			{
				printf("%d %d", x + 2, y - 1);
				return 0;
			}
			if (y - 2 >= 0 && x + 1 <= 10 && x - 2 >= 0 && iniboard[x][y - 2] == 1 && iniboard[x][y - 1] == 0 && iniboard[x + 1][y - 2] == 0 && iniboard[x - 1][y] == 0 && iniboard[x - 2][y] == 0 && iniboard[x - 1][y - 1] == 0)
			{
				printf("%d %d", x - 1, y - 1);
				return 0;
			}
			if (y - 2 >= 0 && x + 1 <= 10 && x - 2 >= 0 && iniboard[x][y - 2] == 0 && iniboard[x][y - 1] == 0 && iniboard[x + 1][y - 2] == 1 && iniboard[x - 1][y] == 0 && iniboard[x - 2][y] == 0 && iniboard[x - 1][y - 1] == 0)
			{
				printf("%d %d", x - 1, y - 1);
				return 0;
			}
			if (y - 2 >= 0 && x - 3 >= 0 && iniboard[x - 1][y - 2] == 1 && iniboard[x - 1][y - 1] == 0 && iniboard[x][y - 2] == 0 && iniboard[x - 2][y] == 0 && iniboard[x - 3][y] == 0 && iniboard[x - 2][y - 1] == 0)
			{
				printf("%d %d", x - 2, y - 1);
				return 0;
			}
			if (y - 2 >= 0 && x - 3 >= 0 && iniboard[x - 1][y - 2] == 0 && iniboard[x - 1][y - 1] == 0 && iniboard[x][y - 2] == 1 && iniboard[x - 2][y] == 0 && iniboard[x - 3][y] == 0 && iniboard[x - 2][y - 1] == 0)
			{
				printf("%d %d", x - 2, y - 1);
				return 0;
			}
		}
		if (y == 1)					//高度为3的边界  6种
		{
			if (y + 1 <= 10 && y - 1 >= 0 && x + 3 <= 10 && iniboard[x][y + 1] == 1 && iniboard[x + 1][y + 1] == 0 && iniboard[x + 1][y] == 0 && iniboard[x + 2][y - 1] == 0 && iniboard[x + 3][y - 1] == 0 && iniboard[x + 2][y] == 0)
			{
				printf("%d %d", x + 2, y);
				return 0;
			}
			if (y + 1 <= 10 && y - 1 >= 0 && x + 3 <= 10 && iniboard[x][y + 1] == 0 && iniboard[x + 1][y + 1] == 1 && iniboard[x + 1][y] == 0 && iniboard[x + 2][y - 1] == 0 && iniboard[x + 3][y - 1] == 0 && iniboard[x + 2][y] == 0)
			{
				printf("%d %d", x + 2, y);
				return 0;
			}
			if (y + 1 <= 10 && y - 1 >= 0 && x - 1 >= 0 && x + 2 <= 10 && iniboard[x - 1][y + 1] == 1 && iniboard[x][y + 1] == 0 && iniboard[x - 1][y - 1] == 0 && iniboard[x][y - 1] == 0 && iniboard[x - 1][y] == 0)
			{
				printf("%d %d", x - 1, y);
				return 0;
			}
			if (y + 1 <= 10 && y - 1 >= 0 && x - 1 >= 0 && x + 2 <= 10 && iniboard[x - 1][y + 1] == 0 && iniboard[x][y + 1] == 1 && iniboard[x + 1][y - 1] == 0 && iniboard[x + 2][y - 1] == 0 && iniboard[x + 1][y] == 0)
			{
				printf("%d %d", x + 1, y);
				return 0;
			}
			if (y + 1 <= 10 && y - 1 >= 0 && x + 1 <= 10 && x - 2 >= 0 && iniboard[x - 2][y + 1] == 1 && iniboard[x - 1][y + 1] == 0 && iniboard[x - 1][y] == 0 && iniboard[x - 2][y - 1] == 0 && iniboard[x - 1][y - 1] == 0 && iniboard[x - 2][y] == 0)
			{
				printf("%d %d", x - 2, y);
				return 0;
			}
			if (y + 1 <= 10 && y - 1 >= 0 && x + 1 <= 10 && x - 2 >= 0 && iniboard[x - 2][y + 1] == 0 && iniboard[x - 1][y + 1] == 1 && iniboard[x - 1][y] == 0 && iniboard[x - 2][y - 1] == 0 && iniboard[x - 1][y - 1] == 0 && iniboard[x - 2][y] == 0)
			{
				printf("%d %d", x - 2, y);
				return 0;
			}
		}
		if (y == 9)
		{
			if (y - 1 >= 0 && y + 1 <= 10 && x - 3 >= 0 && iniboard[x][y - 1] == 1 && iniboard[x - 1][y - 1] == 0 && iniboard[x - 1][y] == 0 && iniboard[x - 2][y + 1] == 0 && iniboard[x - 3][y + 1] == 0 && iniboard[x - 2][y] == 0)
			{
				printf("%d %d", x - 2, y);
				return 0;
			}
			if (y - 1 >= 0 && y + 1 <= 10 && x - 3 >= 0 && iniboard[x][y - 1] == 0 && iniboard[x - 1][y - 1] == 1 && iniboard[x - 1][y] == 0 && iniboard[x - 2][y + 1] == 0 && iniboard[x - 3][y + 1] == 0 && iniboard[x - 2][y] == 0)
			{
				printf("%d %d", x - 2, y);
				return 0;
			}
			if (y - 1 >= 0 && y + 1 <= 10 && x + 1 <= 10 && x - 2 >= 0 && iniboard[x + 1][y - 1] == 1 && iniboard[x][y - 1] == 0 && iniboard[x + 1][y + 1] == 0 && iniboard[x][y + 1] == 0 && iniboard[x + 1][y] == 0)
			{
				printf("%d %d", x + 1, y);
				return 0;
			}
			if (y - 1 >= 0 && y + 1 <= 10 && x + 1 <= 10 && x - 2 >= 0 && iniboard[x + 1][y - 1] == 0 && iniboard[x][y - 1] == 1 && iniboard[x - 1][y + 1] == 0 && iniboard[x - 2][y + 1] == 0 && iniboard[x - 1][y] == 0)
			{
				printf("%d %d", x - 1, y);
				return 0;
			}
			if (y - 1 >= 0 && y + 1 <= 10 && x - 1 >= 0 && x + 2 <= 10 && iniboard[x + 2][y - 1] == 1 && iniboard[x + 1][y - 1] == 0 && iniboard[x + 1][y] == 0 && iniboard[x + 2][y + 1] == 0 && iniboard[x + 1][y + 1] == 0 && iniboard[x + 2][y] == 0)
			{
				printf("%d %d", x + 2, y);
				return 0;
			}
			if (y - 1 >= 0 && y + 1 <= 10 && x - 1 >= 0 && x + 2 <= 10 && iniboard[x + 2][y - 1] == 0 && iniboard[x + 1][y - 1] == 1 && iniboard[x + 1][y] == 0 && iniboard[x + 2][y + 1] == 0 && iniboard[x + 1][y + 1] == 0 && iniboard[x + 2][y] == 0)
			{
				printf("%d %d", x + 2, y);
				return 0;
			}
		}
	}
	return 1;
}




//判断深度
int MCTNode::isTerminal() {
	int depth = 0;
	MCTNode* ptr = this;
	while (ptr->parent != nullptr) {
		depth++;
		ptr = ptr->parent;
	}
	if (depth < 4) {
		return 0;
	}
	else {
		return 1;
	}
}

//输出结果
void MCTNode::Result_Output() {
	printf("%d %d", this->x, this->y);
}

MCTNode::MCTNode(MCTNode* parent, int x, int y)
{
	this->win_time = 0;
	this->parent = parent;
	this->score = 0;
	this->search_time = 0;
	this->x = x, this->y = y;
}

double MCTNode::UCT()
{
	return 1.414 * sqrt(log(this->parent->search_time) / this->search_time) + 1.0 * this->win_time / this->search_time;
}

MCTNode* MCTNode::expand(MCTNode* node) {
	//双距离选点
	//int mycolor = who_first();
	xgznode** better_choice = to_get_twodis_best_point();
	MCTNode* new_node = nullptr;
	
	for (int k = 0; k < xgznode_num; k++) {
		
		new_node = new MCTNode(node, better_choice[k]->i, better_choice[k]->j);
		node->child.emplace_back(new_node);
	}
	return new_node;
}

MCTNode* MCTNode::select(MCTNode* node)
{
	color = 1;
	while (node->isTerminal() == 0) {
		if (!node->child.empty()) {
			node = node->bestChild(node);
		}
		else {
			node = node->expand(node);
			//				return sub_node;
		}
		//补充棋盘
		Current_board[node->x][node->y] = color;
		//补充并查集
		union_find_update(node->x, node->y, color);
		
		color = -color;
		
	}
	
	return node;
	
}
//达到层数后随机落点
int MCTNode::simulate() {
	int randomnode[121];
	for (int i = 0; i < 121; i++) {
		randomnode[i] = i;
	}

	srand(round0);
	random_shuffle(randomnode, randomnode + 121);
	round0++;
	
	for (int i = 0; i < 121; i++) {
		int x, y;
		x = randomnode[i] / 11, y = randomnode[i] % 11;
		if (Current_board[x][y] == 0) {
			Current_board[x][y] = color;
			union_find_update(x, y, color);
			color = -color;
			if (is_win() != 0) {
				return is_win();
			}
		}
	}
	
	return is_win();
}

void MCTNode::backup(MCTNode* node, int reward) {
	while (node != nullptr) {
		if (Current_board[node->x][node->y] == reward) {
			node->win_time ++;
		}
		node->search_time++;
		node = node->parent;
	}
}
MCTNode* MCTNode::bestChild(MCTNode* node)
{
	double UCT_number = 0;
	MCTNode* best = NULL;
	vector<MCTNode*>::iterator p = node->child.begin();
	for (; p != node->child.end(); p++)
	{
		if ((*p)->search_time == 0)
			return (*p);
		else if (UCT_number < (*p)->UCT()){
			UCT_number = (*p)->UCT();
			best = (*p);
		}
	}
	return best;
}

//谁先下
int who_first() {
	if (board[1][2] == -1) {
		return 0;//对面先下
	}
	else {
		return 1;//我们先下
	}
}

MCTNode* MCTNode::monteCarloTreeSearch(int x, int y) {

	round0=0;
	MCTNode* bestchoice = nullptr;
	MCTNode* root = new MCTNode(nullptr, x, y);
	memcpy(board, Current_board, 121 * sizeof(int));        //蒙特卡洛重置用的board初始化
	
	
	current_time = clock();
	while (current_time - start_time < threshold) { //到 0.8 秒立即跳出循环
		
		visited_reset();
		union_board_reset();                                  //变化并查集初始化
		memcpy(Current_board, board, 121 * sizeof(int));
		MCTNode* expand_node = root->select(root);
		int reward = expand_node->simulate();
		backup(expand_node, reward);
		
		current_time = clock();
	}
	
	double final = -1;
	for (int i = 0; i < (int)root->child.size(); i++)
	{
		double node_score = 1.0 * (root->child[i]->win_time) / (root->child[i]->search_time+1);
		if (final < node_score)
		{
			final = node_score;
			bestchoice = root->child[i];
		}
	}
	
	
	return bestchoice;
}










int main()
{
	start_time=clock();
	int x, y, n;
	//恢复目前的棋盘信息
	cin >> n;
	for (int i = 0; i < n - 1; i++) {
		cin >> x >> y; if (x != -1) iniboard[x][y] = -1;	//对方
		cin >> x >> y; if (x != -1) iniboard[x][y] = 1;	//我方
	}
	cin >> x >> y;

//	scanf("%d",&n);
//	for(int i=0 ; i < n-1 ; i++){
//		scanf("%d %d",&x,&y);if (x != -1) iniboard[x][y] = -1;	//对方
//		scanf("%d %d",&x,&y);if (x != -1) iniboard[x][y] = 1;	//我方
//	}
//	scanf("%d %d",&x,&y);

	if (x != -1) iniboard[x][y] = -1;	//对方
	
	//此时board[][]里存储的就是当前棋盘的所有棋子信息,x和y存的是对方最近一步下的棋
	
	
	else {
		printf("1 2");
		return 0;
	}
	//Createdis();
	memcpy(Current_board, iniboard, 121 * sizeof(int));      //复制棋盘
	//破坏防御函数
	int end_sign = protect(x, y);
	if (!end_sign)
		return 0;
	
	
	fill_board();                                         //填充无用位置
	union_find();     									  //重置用的并查集初始化
	union_board_reset();
	if (is_win() == 1) {
		for (int i = 0; i < 11; i++)
		{
			for (int j = 0; j < 11; j++)
			{
				if (i - 1 >= 0 && j - 1 >= 0 && iniboard[i][j] == 1 && iniboard[i - 1][j - 1] == 1 && iniboard[i - 1][j] == 0 && iniboard[i][j - 1] == 0)
				{
					printf("%d %d", i - 1, j);
					return 0;
				}
				if (i - 1 >= 0 && j + 2 <= 10 && iniboard[i][j] == 1 && iniboard[i + 1][j - 2] == 1 && iniboard[i][j - 1] == 0 && iniboard[i + 1][j - 1] == 0)
				{
					printf("%d %d", i, j - 1);
					return 0;
				}
				if (i - 1 >= 0 && j + 2 <= 10 && iniboard[i][j] == 1 && iniboard[i + 2][j - 1] == 1 && iniboard[i + 1][j] == 0 && iniboard[i + 1][j - 1] == 0)
				{
					printf("%d %d", i + 1, j);
					return 0;
				}
				if (i - 1 >= 0 && j + 2 <= 10 && iniboard[i][j] == 1 && iniboard[i - 1][j + 2] == 1 && iniboard[i][j + 1] == 0 && iniboard[i - 1][j + 1] == 0)
				{
					printf("%d %d", i, j + 1);
					return 0;
				}
				if (i + 1 <= 10 && j + 1 <= 10 && iniboard[i][j] == 1 && iniboard[i + 1][j + 1] == 1 && iniboard[i][j + 1] == 0 && iniboard[i + 1][j] == 0)
				{
					printf("%d %d", i, j + 1);
					return 0;
				}
				if (i - 2 >= 0 && j + 1 <= 10 && j - 1 >= 0 && iniboard[i][j] == 1 && iniboard[i - 2][j + 1] == 1 && iniboard[i - 1][j + 1] == 0 && iniboard[i][j - 1] == 0)
				{
					printf("%d %d", i - 1, j + 1);
					return 0;
				}
			}
		}
		return 0;
	}
	
	
	
	MCTNode* bestchoice = nullptr;
	bestchoice = bestchoice->monteCarloTreeSearch(x, y);
	bestchoice->Result_Output();
	
	
	
	
	
	
	
	
	
	// 向平台输出决策结果
	//	cout << new_x << ' ' << new_y << endl;
	return 0;
}
